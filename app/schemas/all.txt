=== Fichier: ./symptom.py ===

from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from datetime import datetime

# ==============================================================================
# Schéma de Base
# ==============================================================================
class SymptomBase(BaseModel):
    """
    Schéma de base pour un symptôme.
    Contient les champs communs à la création et à la lecture.
    """
    nom: str
    nom_local: Optional[str] = None
    categorie: Optional[str] = None
    type_symptome: Optional[str] = None
    description: Optional[str] = None
    questions_anamnese: Optional[Dict[str, Any]] = None
    signes_alarme: bool = False


# ==============================================================================
# Schéma pour la Création (ce que l'API attend dans un POST)
# ==============================================================================
class SymptomCreate(SymptomBase):
    """
    Schéma utilisé pour créer un nouveau symptôme via l'API.
    Hérite de SymptomBase et n'ajoute aucun champ supplémentaire pour l'instant.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour (ce que l'API attend dans un PATCH)
# ==============================================================================
class SymptomUpdate(BaseModel):
    """
    Schéma utilisé pour mettre à jour un symptôme existant.
    Tous les champs sont optionnels pour permettre des mises à jour partielles.
    """
    nom: Optional[str] = None
    nom_local: Optional[str] = None
    categorie: Optional[str] = None
    type_symptome: Optional[str] = None
    description: Optional[str] = None
    questions_anamnese: Optional[Dict[str, Any]] = None
    signes_alarme: Optional[bool] = None


# ==============================================================================
# Schéma pour la Lecture (ce que l'API renvoie)
# ==============================================================================
class Symptom(SymptomBase):
    """
    Schéma complet pour représenter un symptôme, y compris les champs
    générés par la base de données comme 'id' et 'created_at'.
    Ce sera le modèle de réponse de l'API.
    """
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        """
        Configuration pour Pydantic.
        'from_attributes = True' (anciennement 'orm_mode') permet au modèle Pydantic
        de lire les données directement depuis un objet SQLAlchemy.
        C'est le lien magique entre notre modèle de BDD et notre schéma d'API.
        """
        from_attributes = True

=== Fichier: ./medication.py ===

from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime

# ==============================================================================
# Schéma de Base
# ==============================================================================
class MedicationBase(BaseModel):
    """
    Schéma de base pour un médicament, contenant les champs modifiables.
    """
    dci: str
    nom_commercial: Optional[str] = None
    classe_therapeutique: Optional[str] = None
    forme_galenique: Optional[str] = None
    dosage: Optional[str] = None
    voie_administration: Optional[str] = None
    mecanisme_action: Optional[str] = None
    indications: Optional[Dict[str, Any]] = None
    contre_indications: Optional[Dict[str, Any]] = None
    effets_secondaires: Optional[Dict[str, Any]] = None
    interactions_medicamenteuses: Optional[Dict[str, Any]] = None
    precautions_emploi: Optional[str] = None
    posologie_standard: Optional[Dict[str, Any]] = None
    disponibilite_cameroun: Optional[str] = None
    cout_moyen_fcfa: Optional[int] = None
    statut_prescription: Optional[str] = None


# ==============================================================================
# Schéma pour la Création
# ==============================================================================
class MedicationCreate(MedicationBase):
    """
    Schéma utilisé pour créer un nouveau médicament.
    'dci' est le seul champ strictement requis.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour
# ==============================================================================
class MedicationUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle d'un médicament.
    """
    dci: Optional[str] = None
    nom_commercial: Optional[str] = None
    classe_therapeutique: Optional[str] = None
    # ... (tous les autres champs de MedicationBase en optionnel)
    forme_galenique: Optional[str] = None
    dosage: Optional[str] = None
    voie_administration: Optional[str] = None
    mecanisme_action: Optional[str] = None
    indications: Optional[Dict[str, Any]] = None
    contre_indications: Optional[Dict[str, Any]] = None
    effets_secondaires: Optional[Dict[str, Any]] = None
    interactions_medicamenteuses: Optional[Dict[str, Any]] = None
    precautions_emploi: Optional[str] = None
    posologie_standard: Optional[Dict[str, Any]] = None
    disponibilite_cameroun: Optional[str] = None
    cout_moyen_fcfa: Optional[int] = None
    statut_prescription: Optional[str] = None


# ==============================================================================
# Schéma pour la Lecture (Réponse API)
# ==============================================================================
class Medication(MedicationBase):
    """
    Schéma complet pour représenter un médicament en réponse d'API.
    """
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

=== Fichier: ./clinical_case.py ===

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime, date
from decimal import Decimal

# Importer les autres schémas pour les réponses imbriquées
from .disease import Disease
from .media import ImageMedicale
from .symptom import Symptom






# --- NOUVEAUX SOUS-SCHÉMAS ---
class SymptomInCase(BaseModel):
    symptome_id: int
    details: str # Ex: "Fièvre élevée (40°C) apparue brutalement il y a 48h"

class PresentationClinique(BaseModel):
    histoire_maladie: str
    symptomes_patient: List[SymptomInCase]
    antecedents: Optional[Dict[str, Any]] = None
# ==============================================================================
# Schéma de Base et de Création
# ==============================================================================
class ClinicalCaseBase(BaseModel):
    """
    Schéma de base pour un cas clinique, contenant les champs éditables.
    """
    code_fultang: str = Field(..., description="Identifiant unique (Fultang ou synthétique)")
    pathologie_principale_id: Optional[int] = None
    pathologies_secondaires_ids: Optional[List[int]] = []
    presentation_clinique: PresentationClinique
    donnees_paracliniques: Optional[Dict[str, Any]] = None
    evolution_patient: Optional[str] = None
    images_associees_ids: Optional[List[int]] = []
    sons_associes_ids: Optional[List[int]] = []
    medicaments_prescrits: Optional[List[Dict[str, Any]]] = []
    niveau_difficulte: int = Field(default=3, ge=1, le=101)
    duree_estimee_resolution_min: Optional[int] = None
    objectifs_apprentissage: Optional[List[str]] = []
    competences_requises: Optional[Dict[str, Any]] = {}


class ClinicalCaseCreate(ClinicalCaseBase):
    """
    Schéma utilisé pour créer un nouveau cas clinique via l'API.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour
# ==============================================================================
class ClinicalCaseUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle d'un cas clinique.
    """
    code_fultang: Optional[str] = None
    pathologie_principale_id: Optional[int] = None
    presentation_clinique: Optional[Dict[str, Any]] = None
    donnees_paracliniques: Optional[Dict[str, Any]] = None
    evolution_patient: Optional[str] = None
    images_associees_ids: Optional[List[int]] = None
    sons_associes_ids: Optional[List[int]] = None
    medicaments_prescrits: Optional[List[Dict[str, Any]]] = None
    niveau_difficulte: Optional[int] = Field(None, ge=1, le=101)
    duree_estimee_resolution_min: Optional[int] = None
    objectifs_apprentissage: Optional[List[str]] = None
    competences_requises: Optional[Dict[str, Any]] = None
    valide_expert: Optional[bool] = None
    expert_validateur: Optional[str] = None
    date_validation: Optional[date] = None


# ==============================================================================
# Schémas pour la Lecture (Réponse API)
# ==============================================================================
class ClinicalCaseSimple(BaseModel):
    """
    Schéma simplifié pour les listes de cas cliniques.
    """
    id: int
    code_fultang: str
    niveau_difficulte: int
    pathologie_principale: Optional[Disease] = None # Affiche l'objet maladie complet
    nb_images: int
    nb_sons: int

    class Config:
        from_attributes = True


# --- NOUVEAU SCHÉMA DE LECTURE ENRICHI ---
class SymptomDetailInCase(BaseModel):
    symptome: Symptom # L'objet symptôme complet
    details: str # Les détails spécifiques au cas

class PresentationCliniqueDetail(BaseModel):
    histoire_maladie: str
    symptomes_patient: List[SymptomDetailInCase]
    antecedents: Optional[Dict[str, Any]] = None


class ClinicalCase(ClinicalCaseBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    pathologie_principale: Optional[Disease] = None
    pathologies_secondaires: List[Disease] = [] # <- AJOUTER
    images_associees: List[ImageMedicale] = []
    
    # --- ENRICHISSEMENT DE LA PRÉSENTATION CLINIQUE ---
    presentation_clinique_detail: Optional[PresentationCliniqueDetail] = None

    class Config:
        from_attributes = True



=== Fichier: ./relations.py ===

from pydantic import BaseModel, Field
from typing import Any, Dict, Optional
from decimal import Decimal

# Importer les schémas de base pour l'affichage
from .symptom import Symptom
from .disease import Disease
from .medication import Medication


# ==============================================================================
# Schéma de Base et de Création pour l'Association
# ==============================================================================
class PathologieSymptomeBase(BaseModel):
    """
    Schéma de base pour l'association Pathologie-Symptôme.
    Contient les champs nécessaires pour créer ou mettre à jour le lien.
    """
    pathologie_id: int
    symptome_id: int
    probabilite: Optional[Decimal] = Field(None, ge=0, le=1)
    sensibilite: Optional[Decimal] = Field(None, ge=0, le=1)
    specificite: Optional[Decimal] = Field(None, ge=0, le=1)
    phase_maladie: Optional[str] = None
    frequence: Optional[str] = None
    est_pathognomonique: bool = False
    importance_diagnostique: Optional[int] = Field(None, ge=1, le=5)

class PathologieSymptomeCreate(PathologieSymptomeBase):
    """
    Schéma utilisé spécifiquement pour créer une nouvelle association.
    """
    pass


# ==============================================================================
# Schémas pour la Lecture (Réponse de l'API)
# ==============================================================================
class PathologieSymptome(PathologieSymptomeBase):
    """
    Schéma complet pour la réponse de l'API, incluant l'ID de l'association.
    """
    id: int

    class Config:
        from_attributes = True


class SymptomForDiseaseDetail(BaseModel):
    """
    Schéma pour afficher les détails d'un symptôme DANS le contexte d'une pathologie.
    """
    symptome: Symptom
    probabilite: Optional[Decimal]
    importance_diagnostique: Optional[int]
    est_pathognomonique: bool

    class Config:
        from_attributes = True


class DiseaseForSymptomDetail(BaseModel):
    """
    Schéma pour afficher les détails d'une pathologie DANS le contexte d'un symptôme
    (utile pour le diagnostic différentiel).
    """
    pathologie: Disease
    probabilite: Optional[Decimal]
    importance_diagnostique: Optional[int]

    class Config:
        from_attributes = True



# Contenu à AJOUTER à la fin de app/schemas/relations.py

# Importer le schéma de base pour l'affichage


# ==============================================================================
# Schémas pour l'Association Traitement-Pathologie
# ==============================================================================
class TraitementPathologieBase(BaseModel):
    pathologie_id: int
    medicament_id: int
    type_traitement: Optional[str] = None
    ligne_traitement: Optional[int] = None
    indication_precise: Optional[str] = None
    efficacite_taux: Optional[Decimal] = Field(None, ge=0, le=100)
    duree_traitement_jours: Optional[int] = None
    posologie_detaillee: Optional[Dict[str, Any]] = None
    niveau_preuve: Optional[str] = None
    guidelines_source: Optional[str] = None
    rang_preference: Optional[int] = 99

class TraitementPathologieCreate(TraitementPathologieBase):
    pass

class TraitementPathologie(TraitementPathologieBase):
    id: int
    class Config:
        from_attributes = True

class MedicationForDiseaseDetail(BaseModel):
    """
    Schéma pour afficher les détails d'un médicament DANS le contexte d'une pathologie.
    """
    medicament: Medication
    type_traitement: Optional[str]
    ligne_traitement: Optional[int]
    rang_preference: Optional[int]
    
    class Config:
        from_attributes = True

# ==============================================================================
# Schémas pour l'Association Traitement-Symptôme
# ==============================================================================
class TraitementSymptomeBase(BaseModel):
    symptome_id: int
    medicament_id: int
    efficacite: Optional[str] = None
    rapidite_action: Optional[str] = None
    posologie_recommandee: Optional[str] = None
    rang_preference: Optional[int] = 99

class TraitementSymptomeCreate(TraitementSymptomeBase):
    pass

class TraitementSymptome(TraitementSymptomeBase):
    id: int
    class Config:
        from_attributes = True

class MedicationForSymptomDetail(BaseModel):
    """
    Schéma pour afficher les détails d'un médicament DANS le contexte d'un symptôme.
    """
    medicament: Medication
    efficacite: Optional[str]
    rang_preference: Optional[int]

    class Config:
        from_attributes = True

=== Fichier: ./tracking_models.py ===



=== Fichier: ./__init__.py ===

# ==============================================================================
# FICHIER D'INITIALISATION DU PACKAGE 'schemas'
# ------------------------------------------------------------------------------
# Ce fichier a deux rôles principaux :
# 1. Il signale à Python que le dossier 'schemas' est un "package", c'est-à-dire
#    un ensemble de modules qui peuvent être importés.
# 2. Il définit ce qui est accessible publiquement lorsque l'on importe 'schemas'.
#    C'est le "hall d'entrée" du package.
# ==============================================================================

# --- IMPORTS EXISTANTS (validés) ---
# Chaque ligne rend des classes spécifiques directement accessibles
# depuis le package 'schemas'.
# Exemple : `from app import schemas` puis `schemas.Symptom`

from .symptom import SymptomCreate, SymptomBase, SymptomUpdate, Symptom
from .disease import DiseaseCreate, DiseaseBase, DiseaseUpdate, Disease
from .medication import MedicationCreate, MedicationBase, MedicationUpdate, Medication
from .media import ImageMedicaleBase, ImageMedicaleUpdate, ImageMedicale
from .clinical_case import ClinicalCaseCreate, ClinicalCaseBase, ClinicalCaseUpdate, ClinicalCase
from .expert_strategy import ExpertStrategyCreate, ExpertStrategyBase, ExpertStrategyUpdate, ExpertStrategy

# --- NOUVEAUX IMPORTS (pour corriger les erreurs) ---

# 1. CORRECTION POUR 'chat_message'
# Cette ligne importe les classes `ChatMessage` et `ChatMessageCreate` depuis le
# fichier `chat_message.py`. Sans cela, l'erreur `AttributeError: module 'app.schemas'
# has no attribute 'ChatMessageCreate'` se produit.
from .chat_message import ChatMessage, ChatMessageCreate

# 2. IMPORTATION DES MODULES COMPLETS
# Pour les schémas complexes comme 'relations' et 'simulation', il est souvent
# plus propre d'importer le module entier.
# Cela signifie qu'on y accédera avec une syntaxe comme `schemas.simulation.SessionStartRequest`.
# C'est ce que nous avons déjà fait dans le code des services.

# Rend le module 'relations.py' accessible via `schemas.relations`
from . import relations

# Rend le module 'simulation.py' accessible via `schemas.simulation`.
# C'est cette ligne qui a corrigé la première erreur `AttributeError` que vous aviez.
from . import simulation

# ==============================================================================
# FIN DU FICHIER
# ------------------------------------------------------------------------------
# Avec ce fichier, l'application sait maintenant où trouver TOUS les schémas
# Pydantic dont elle a besoin, que ce soit par import direct de classe
# (ex: schemas.Symptom) ou par import de module (ex: schemas.simulation.HintResponse).
# ==============================================================================

=== Fichier: ./simulation.py ===

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from uuid import UUID

from .clinical_case import ClinicalCase

# ==============================================================================
# SCHÉMAS POUR LE DÉMARRAGE D'UNE SESSION
# ==============================================================================

class SessionStartRequest(BaseModel):
    learner_id: int = Field(..., description="L'ID de l'apprenant qui commence la session.")
    category: str = Field(..., description="La catégorie de pathologie choisie (ex: 'Cardiologie').")

class SessionStartResponse(BaseModel):
    session_id: UUID = Field(..., description="L'ID unique de la session créée.")
    session_type: str = Field(..., description="Le type de session (test, formative, sommative).")
    clinical_case: ClinicalCase = Field(..., description="Les détails complets du cas clinique sélectionné.")

    class Config:
        from_attributes = True

# ==============================================================================
# SCHÉMAS POUR LES ACTIONS DE L'APPRENANT
# ==============================================================================

class LearnerActionRequest(BaseModel):
    action_type: str = Field(..., description="Le type d'action (ex: 'parametres_vitaux', 'examen_complementaire').")
    action_name: str = Field(..., description="Le nom spécifique de l'action (ex: 'Prise des constantes', 'NFS').")
    justification: Optional[str] = Field(None, description="La justification de l'apprenant pour cette action.")

class LearnerActionResponse(BaseModel):
    action_type: str
    action_name: str
    result: Dict[str, Any] = Field(..., description="Le résultat de l'action (ex: rapport et conclusion d'un examen).")
    feedback: Optional[str] = Field(None, description="Un feedback immédiat du tuteur sur la pertinence de l'action.")

# ==============================================================================
# SCHÉMA POUR LA RÉPONSE D'INDICE
# ==============================================================================

class HintResponse(BaseModel):
    hint_type: str = Field(..., description="Le type d'indice (ex: 'question_socratique', 'indice_direct').")
    content: str = Field(..., description="Le contenu textuel de l'indice.")

# ==============================================================================
# SCHÉMAS POUR LA SOUMISSION ET L'ÉVALUATION FINALE
# ==============================================================================

class SubmissionRequest(BaseModel):
    diagnosed_pathology_id: int = Field(..., description="L'ID de la pathologie principale diagnostiquée.")
    prescribed_medication_ids: List[int] = Field(default_factory=list, description="Liste des IDs des médicaments prescrits.")

class EvaluationResult(BaseModel):
    """
    Détaille les différentes composantes du score final, sur un total de 20 points.
    """
    score_diagnostic: float = Field(..., description="Score pour la justesse du diagnostic (sur 10).")
    score_therapeutique: float = Field(..., description="Score pour la pertinence du traitement (sur 5).")
    score_demarche: float = Field(..., description="Score pour la démarche clinique (sur 5).")
    score_total: float = Field(..., description="Score total sur 20.")

class SubmissionResponse(BaseModel):
    """
    Réponse de l'API après l'évaluation de la soumission de l'apprenant.
    """
    evaluation: EvaluationResult = Field(..., description="Le détail du score obtenu.")
    feedback_global: str = Field(..., description="Un commentaire global sur la performance.")
    recommendation_next_step: str = Field(..., description="Recommandation pour la suite du parcours.")

=== Fichier: ./expert_strategy.py ===

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime, date
from decimal import Decimal

# ==============================================================================
# Schéma de Base
# ==============================================================================
class ExpertStrategyBase(BaseModel):
    """
    Schéma de base pour une règle/stratégie experte.
    """
    code_regle: str = Field(..., max_length=50)
    categorie: str
    priorite: int = Field(default=5, ge=1, le=10)
    conditions: Dict[str, Any]
    actions: List[Dict[str, Any]]
    description_naturelle: Optional[str] = None
    justification_medicale: Optional[str] = None
    expert_auteur: Optional[str] = None
    date_validation: Optional[date] = None
    est_active: bool = True


# ==============================================================================
# Schéma pour la Création
# ==============================================================================
class ExpertStrategyCreate(ExpertStrategyBase):
    """
    Schéma utilisé pour créer une nouvelle règle.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour
# ==============================================================================
class ExpertStrategyUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle d'une règle.
    """
    code_regle: Optional[str] = Field(None, max_length=50)
    categorie: Optional[str] = None
    priorite: Optional[int] = Field(None, ge=1, le=10)
    conditions: Optional[Dict[str, Any]] = None
    actions: Optional[List[Dict[str, Any]]] = None
    description_naturelle: Optional[str] = None
    justification_medicale: Optional[str] = None
    expert_auteur: Optional[str] = None
    date_validation: Optional[date] = None
    est_active: Optional[bool] = None


# ==============================================================================
# Schéma pour la Lecture (Réponse API)
# ==============================================================================
class ExpertStrategy(ExpertStrategyBase):
    """
    Schéma complet pour représenter une règle en réponse d'API.
    """
    id: int
    nb_activations: int
    taux_succes: Optional[Decimal] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

=== Fichier: ./response.py ===



=== Fichier: ./media.py ===

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime, date

# ==============================================================================
# Schéma de Base pour les Métadonnées d'une Image
# ==============================================================================
class ImageMedicaleBase(BaseModel):
    """
    Schéma de base contenant les métadonnées modifiables d'une image médicale.
    """
    type_examen: str
    sous_type: Optional[str] = None
    pathologie_id: Optional[int] = None
    description: Optional[str] = None
    signes_radiologiques: Optional[Dict[str, Any]] = None
    annotations: Optional[List[Dict[str, Any]]] = None
    interpretation_experte: Optional[str] = None
    diagnostic_differentiel: Optional[List[str]] = None
    niveau_difficulte: Optional[int] = Field(None, ge=1, le=5)
    qualite_image: Optional[int] = Field(None, ge=1, le=5)
    valide_expert: Optional[bool] = False
    expert_validateur: Optional[str] = None
    date_validation: Optional[date] = None


# ==============================================================================
# Schéma pour la Mise à Jour des Métadonnées
# ==============================================================================
class ImageMedicaleUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle des métadonnées d'une image.
    Tous les champs sont optionnels.
    """
    type_examen: Optional[str] = None
    sous_type: Optional[str] = None
    pathologie_id: Optional[int] = None
    description: Optional[str] = None
    signes_radiologiques: Optional[Dict[str, Any]] = None
    annotations: Optional[List[Dict[str, Any]]] = None
    interpretation_experte: Optional[str] = None
    diagnostic_differentiel: Optional[List[str]] = None
    niveau_difficulte: Optional[int] = Field(None, ge=1, le=5)
    qualite_image: Optional[int] = Field(None, ge=1, le=5)
    valide_expert: Optional[bool] = None
    expert_validateur: Optional[str] = None
    date_validation: Optional[date] = None


# ==============================================================================
# Schéma pour la Lecture (Réponse API)
# ==============================================================================
class ImageMedicale(ImageMedicaleBase):
    """
    Schéma complet pour représenter les métadonnées d'une image en réponse d'API.
    """
    id: int
    fichier_url: str
    fichier_miniature_url: Optional[str] = None
    format_image: Optional[str] = None
    taille_ko: Optional[int] = None
    resolution: Optional[str] = None
    created_at: datetime

    class Config:
        from_attributes = True

# Nous ajouterons les schémas pour SonMedical ici plus tard.

=== Fichier: ./disease.py ===

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime
from decimal import Decimal

# ==============================================================================
# Schéma de Base
# ==============================================================================
class DiseaseBase(BaseModel):
    """
    Schéma de base pour une pathologie, contenant les champs modifiables.
    """
    nom_fr: str
    code_icd10: str
    nom_en: Optional[str] = None
    nom_local: Optional[str] = None
    categorie: Optional[str] = None
    prevalence_cameroun: Optional[Decimal] = Field(None, ge=0, le=100)
    niveau_gravite: Optional[int] = Field(None, ge=1, le=5)
    description: Optional[str] = None
    physiopathologie: Optional[str] = None
    evolution_naturelle: Optional[str] = None
    complications: Optional[Dict[str, Any]] = None
    facteurs_risque: Optional[Dict[str, Any]] = None
    prevention: Optional[str] = None


# ==============================================================================
# Schéma pour la Création (ce que l'API attend dans un POST)
# ==============================================================================
class DiseaseCreate(DiseaseBase):
    """
    Schéma utilisé pour créer une nouvelle pathologie.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour (ce que l'API attend dans un PATCH)
# ==============================================================================
class DiseaseUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle d'une pathologie.
    Tous les champs sont optionnels.
    """
    nom_fr: Optional[str] = None
    code_icd10: Optional[str] = None
    nom_en: Optional[str] = None
    nom_local: Optional[str] = None
    categorie: Optional[str] = None
    prevalence_cameroun: Optional[Decimal] = Field(None, ge=0, le=100)
    niveau_gravite: Optional[int] = Field(None, ge=1, le=5)
    description: Optional[str] = None
    physiopathologie: Optional[str] = None
    evolution_naturelle: Optional[str] = None
    complications: Optional[Dict[str, Any]] = None
    facteurs_risque: Optional[Dict[str, Any]] = None
    prevention: Optional[str] = None


# ==============================================================================
# Schéma pour la Lecture (ce que l'API renvoie)
# ==============================================================================
class Disease(DiseaseBase):
    """
    Schéma complet pour représenter une pathologie en réponse d'API.
    Inclut les champs non modifiables comme 'id' et les horodatages.
    """
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        """
        Permet la conversion automatique depuis un objet SQLAlchemy.
        """
        from_attributes = True

=== Fichier: ./diagnostic.py ===



=== Fichier: ./chat_message.py ===

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from datetime import datetime
from uuid import UUID

# ==============================================================================
# Schéma de Base
# ==============================================================================
class ChatMessageBase(BaseModel):
    """
    Schéma de base pour un message de chat.
    Contient les champs communs.
    """
    sender: str = Field(..., description="Qui envoie le message (ex: 'student', 'patient_llm', 'tutor_system')")
    content: str = Field(..., description="Le contenu textuel du message.")


# ==============================================================================
# Schéma pour la Création (ce que le Frontend envoie)
# ==============================================================================
class ChatMessageCreate(ChatMessageBase):
    """
    Schéma utilisé pour créer un nouveau message de chat via l'API.
    La session_id sera fournie dans l'URL, pas dans le corps.
    """
    message_metadata: Optional[Dict[str, Any]] = Field(None, description="Métadonnées optionnelles (ex: intention détectée)")


# ==============================================================================
# Schéma pour la Lecture (ce que l'API renvoie)
# ==============================================================================
class ChatMessage(ChatMessageBase):
    """
    Schéma complet pour représenter un message de chat en réponse d'API.
    """
    id: int
    session_id: UUID
    timestamp: datetime
    message_metadata: Optional[Dict[str, Any]] = None

    class Config:
        """
        Permet la conversion automatique depuis un objet SQLAlchemy.
        """
        from_attributes = True

=== Fichier: ./base.py ===



=== Fichier: ./request.py ===



