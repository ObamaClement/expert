=== Fichier: ./tutor_models.py ===

from sqlalchemy import Column, Integer, String, Text, Float, ForeignKey, JSON, TIMESTAMP, text, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
from .base import Base

class LearningPath(Base):
    __tablename__ = "learning_paths"

    id = Column(Integer, primary_key=True, index=True)
    learner_id = Column(Integer, ForeignKey("learners.id"), nullable=False)
    
    algorithme_recommandation = Column(String(100))
    ordered_case_ids = Column(JSON, comment="Liste ordonnée des IDs des cas") 
    progression = Column(Float, default=0.0)
    status = Column(String(50), default="in_progress")
    created_at = Column(TIMESTAMP, server_default=text("now()"))

    learner = relationship("Learner")


class TutorDecision(Base):
    __tablename__ = "tutor_decisions"

    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    trigger_event_id = Column(Integer, ForeignKey("interaction_logs.id"), nullable=True)
    
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    strategy_used = Column(String(100)) # Socratique, Scaffolding...
    action_choisie = Column(String(100)) # Hint, Encouragement
    intervention_content = Column(Text)
    rationale = Column(JSON) # Pourquoi j'ai fait ça ?
    succes_intervention = Column(Boolean, nullable=True)

    session = relationship("SimulationSession", back_populates="tutor_decisions")


class TutorStrategiesHistory(Base):
    __tablename__ = "tutor_strategies_history"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    strategy_name = Column(String(100))
    relevance_score = Column(Float)


class TutorScaffoldingState(Base):
    __tablename__ = "tutor_scaffolding_state"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    competence_cible_id = Column(Integer, ForeignKey("competences_cliniques.id"))
    current_level = Column(Integer, default=0)
    indices_deja_donnes = Column(JSON)


class TutorSocraticState(Base):
    __tablename__ = "tutor_socratic_state"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    tactic_used = Column(String(100))
    target_concept = Column(String(255))
    step_in_dialogue = Column(Integer)


class TutorMotivationalState(Base):
    __tablename__ = "tutor_motivational_state"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    intervention_type = Column(String(100))
    emotional_state_before = Column(JSON)


class TutorFeedbackLog(Base):
    __tablename__ = "tutor_feedback_logs"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    feedback_type = Column(String(50))
    content = Column(Text)

=== Fichier: ./symptom.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    Boolean,
    JSON,
    TIMESTAMP,
    text
)
from pgvector.sqlalchemy import Vector
from sqlalchemy.orm import relationship

from .base import Base


class Symptom(Base):
    """
    Modèle SQLAlchemy pour la table des symptômes.

    Cette table est le catalogue central de tous les symptômes connus par le système expert.
    Elle inclut des informations détaillées pour permettre un raisonnement clinique fin
    et des recherches sémantiques.
    """
    __tablename__ = "symptomes"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification et Catégorisation ---
    nom = Column(String(255), nullable=False, unique=True, index=True)
    nom_local = Column(String(255), comment="Nom vernaculaire ou local, ex: 'Ntou-tou' pour la toux")
    categorie = Column(String(100), index=True, comment="Catégorie fonctionnelle (ex: Respiratoire, Neurologique, Digestif)")
    type_symptome = Column(String(50), comment="Type de symptôme (ex: Subjectif, Objectif, Signe clinique)")

    # --- Description et Contexte Clinique ---
    description = Column(Text, comment="Description détaillée du symptôme et de sa signification clinique.")
    questions_anamnese = Column(JSON, comment="Liste structurée de questions pour explorer ce symptôme (ex: PQRST)")
    signes_alarme = Column(Boolean, default=False, nullable=False, comment="Indique si ce symptôme est un signe de gravité ('red flag')")

    # --- Intelligence Artificielle ---
    embedding_vector = Column(Vector(384), nullable=True, comment="Vecteur d'embedding pour la recherche sémantique (ex: BioBERT)")

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    # --- Relations ---
    # Relation vers la table d'association 'pathologie_symptomes'
    # 'back_populates' assure la synchronisation de la relation des deux côtés.
    # 'cascade' signifie que si un symptôme est supprimé, ses associations le seront aussi.
    pathologies = relationship(
        "PathologieSymptome",
        back_populates="symptome",
        cascade="all, delete-orphan"
    )
    traitements = relationship(
        "TraitementSymptome",
        back_populates="symptome",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Symptom(id={self.id}, nom='{self.nom}')>"

=== Fichier: ./medication.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    text
)
from pgvector.sqlalchemy import Vector
from sqlalchemy.orm import relationship
from .base import Base


class Medication(Base):
    """
    Modèle SQLAlchemy pour la table des médicaments.

    Cette table est le catalogue central de tous les médicaments connus par le système,
    incluant des informations pharmacologiques et contextuelles (disponibilité, coût).
    """
    __tablename__ = "medicaments"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification ---
    nom_commercial = Column(String(255), index=True)
    dci = Column(String(255), nullable=False, index=True, comment="Dénomination Commune Internationale")
    
    # --- Classification et Formulation ---
    classe_therapeutique = Column(String(255), index=True)
    forme_galenique = Column(String(100), comment="Ex: Comprimé, Sirop, Injectable")
    dosage = Column(String(100))
    voie_administration = Column(String(100), comment="Ex: Orale, IV, IM, Cutanée")

    # --- Informations Pharmacologiques ---
    mecanisme_action = Column(Text)
    indications = Column(JSON)
    contre_indications = Column(JSON)
    effets_secondaires = Column(JSON)
    interactions_medicamenteuses = Column(JSON)
    precautions_emploi = Column(Text)
    posologie_standard = Column(JSON, comment="Posologie standard par âge, poids, indication")

    # --- Contexte Local (Cameroun) ---
    disponibilite_cameroun = Column(String(50), comment="Ex: Urbain, Rural, CHU_uniquement")
    cout_moyen_fcfa = Column(Integer)
    statut_prescription = Column(String(50), comment="Ex: Prescription_obligatoire, OTC")

    # --- Intelligence Artificielle ---
    embedding_vector = Column(Vector(384), nullable=True, comment="Vecteur d'embedding pour la recherche de médicaments similaires")

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    traitements_pathologies = relationship("TraitementPathologie", back_populates="medicament")
    traitements_symptomes = relationship("TraitementSymptome", back_populates="medicament")

    def __repr__(self) -> str:
        return f"<Medication(id={self.id}, dci='{self.dci}')>"

=== Fichier: ./clinical_case.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    Boolean,
    Date,
    ForeignKey,
    ARRAY,
    DECIMAL,
    text
)
from sqlalchemy.orm import relationship
from pgvector.sqlalchemy import Vector

from .base import Base


class ClinicalCase(Base):
    """
    Modèle SQLAlchemy pour la table des cas cliniques enrichis.
    C'est l'objet central utilisé pour les scénarios d'apprentissage.
    """
    __tablename__ = "cas_cliniques_enrichis"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification et Intégrité ---
    code_fultang = Column(String(100), unique=True, index=True, comment="Identifiant unique provenant de Fultang (ou synthétique)")
    hash_integrite = Column(String(64), nullable=True, comment="SHA-256 pour la preuve d'intégrité des données brutes")

    # --- Liaisons aux Connaissances de Base ---
    pathologie_principale_id = Column(Integer, ForeignKey("pathologies.id"), nullable=True, index=True)
    pathologies_secondaires_ids = Column(ARRAY(Integer), comment="Liste d'IDs de pathologies comorbides ou secondaires")

    # --- Données du Scénario ---
    donnees_brutes = Column(JSON, nullable=True, comment="Données originales (ex: de Fultang) avant traitement")
    presentation_clinique = Column(JSON, nullable=False, comment="Histoire du patient, symptômes présentés, etc.")
    donnees_paracliniques = Column(JSON, comment="Résultats des examens pour ce cas spécifique")
    evolution_patient = Column(Text, comment="Description de l'évolution du patient pendant le cas")
    
    # --- Liaisons Multimédia ---
    images_associees_ids = Column(ARRAY(Integer), comment="Liste des IDs des images de la table 'images_medicales'")
    sons_associes_ids = Column(ARRAY(Integer), comment="Liste des IDs des sons de la table 'sons_medicaux'")

    # --- Liaisons Thérapeutiques ---
    medicaments_prescrits = Column(JSON, comment="Liste des médicaments prescrits dans ce cas")

    # --- Métadonnées Pédagogiques ---
    niveau_difficulte = Column(Integer, default=3, comment="Difficulté du cas (1-5)")
    duree_estimee_resolution_min = Column(Integer, comment="Temps estimé pour résoudre le cas")
    objectifs_apprentissage = Column(JSON, comment="Liste des compétences à acquérir")
    competences_requises = Column(JSON, comment="Mapping Q-Matrix pour ce cas")

    valide_expert = Column(Boolean, default=False)
    
    # Clé étrangère vers la table experts
    expert_validateur_id = Column(Integer, ForeignKey("experts.id"), nullable=True)
    
    # Relation avec ExpertUser
    expert_validateur = relationship("ExpertUser", back_populates="cas_valides")
    date_validation = Column(Date)

    qualite_donnees = Column(Integer, comment="Qualité des données sources (1-5)")

    # --- Métriques d'Utilisation ---
    nb_utilisations = Column(Integer, default=0)
    note_moyenne_apprenants = Column(DECIMAL(3, 2))
    taux_succes_diagnostic = Column(DECIMAL(5, 2))
    
    # --- Intelligence Artificielle ---
    embedding_texte = Column(Vector(384), nullable=True, comment="Embedding de la description textuelle du cas")
    embedding_global = Column(Vector(1536), nullable=True, comment="Embedding multimodal fusionné (texte+image+son)")
    
    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    # --- Relations ---
    pathologie_principale = relationship("Disease")

    def __repr__(self) -> str:
        return f"<ClinicalCase(id={self.id}, code='{self.code_fultang}')>"

=== Fichier: ./learner_models.py ===

from sqlalchemy import Column, Integer, String, Float, ForeignKey, JSON, TIMESTAMP, text, Boolean
from sqlalchemy.orm import relationship
from .base import Base

class Learner(Base):
    __tablename__ = "learners"

    id = Column(Integer, primary_key=True, index=True)
    matricule = Column(String(50), unique=True, index=True)
    nom = Column(String(255))
    email = Column(String(255), unique=True, index=True)
    niveau_etudes = Column(String(50)) # Med 3, Interne...
    specialite_visee = Column(String(100))
    langue_preferee = Column(String(10), default="fr")
    date_inscription = Column(TIMESTAMP, server_default=text("now()"))

    # Relations
    competency_mastery = relationship("LearnerCompetencyMastery", back_populates="learner")
    misconceptions = relationship("LearnerMisconception", back_populates="learner")
    sessions = relationship("SimulationSession", back_populates="learner")


class LearnerCompetencyMastery(Base):
    __tablename__ = "learner_competency_mastery"

    id = Column(Integer, primary_key=True, index=True)
    learner_id = Column(Integer, ForeignKey("learners.id"), nullable=False)
    competence_id = Column(Integer, ForeignKey("competences_cliniques.id"), nullable=False)
    
    mastery_level = Column(Float, default=0.0) # Probabilité BKT (0-1)
    confidence = Column(Float, default=0.0) # Certitude du système
    last_practice_date = Column(TIMESTAMP)
    nb_success = Column(Integer, default=0)
    nb_failures = Column(Integer, default=0)
    streak_correct = Column(Integer, default=0)

    learner = relationship("Learner", back_populates="competency_mastery")
    competence = relationship("Competence") # Lien vers Module Expert


class LearnerCognitiveProfile(Base):
    __tablename__ = "learner_cognitive_profiles"

    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"), unique=True)
    
    vitesse_assimilation = Column(Float)
    capacite_memoire_travail = Column(Float)
    tendance_impulsivite = Column(Float) # 0 (Réfléchi) - 1 (Impulsif)
    prefer_visual = Column(Boolean, default=False)
    
    learner = relationship("Learner")


class LearnerMisconception(Base):
    __tablename__ = "learner_misconceptions"

    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    
    type_erreur = Column(String(255)) # ex: "Confond Virus/Bactérie"
    frequence_apparition = Column(Integer, default=1)
    resistance_correction = Column(Float, default=0.0) # 0-1
    detected_at = Column(TIMESTAMP, server_default=text("now()"))
    
    learner = relationship("Learner", back_populates="misconceptions")


class LearnerGoal(Base):
    __tablename__ = "learner_goals"
    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    type_objectif = Column(String(100))
    domaine_cible = Column(String(100))
    date_limite = Column(TIMESTAMP)
    statut = Column(String(50)) # en_cours, atteint, abandonne


class LearnerPreference(Base):
    __tablename__ = "learner_preferences"
    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    cle = Column(String(100))
    valeur = Column(String(255))


class LearnerAchievement(Base):
    __tablename__ = "learner_achievements"
    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    badge_id = Column(String(100))
    date_obtention = Column(TIMESTAMP, server_default=text("now()"))


class LearnerStrategy(Base):
    __tablename__ = "learner_strategies"
    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    strategy_name = Column(String(100)) # ex: "Gaming", "Help Seeking"
    frequency = Column(Integer)
    effectiveness = Column(Float)

=== Fichier: ./relations.py ===

from sqlalchemy import (
    JSON,
    Column,
    Integer,
    ForeignKey,
    DECIMAL,
    String,
    Boolean,
    Text
)
from sqlalchemy.orm import relationship

from .base import Base


class PathologieSymptome(Base):
    """
    Modèle de la table d'association entre Pathologies et Symptômes.

    Cette table matérialise la relation "plusieurs-à-plusieurs" et permet de stocker
    des informations contextuelles sur le lien, telles que la probabilité
    d'apparition, la spécificité, etc.
    """
    __tablename__ = "pathologie_symptomes"

    id = Column(Integer, primary_key=True)

    # --- Clés Étrangères ---
    pathologie_id = Column(Integer, ForeignKey("pathologies.id"), nullable=False)
    symptome_id = Column(Integer, ForeignKey("symptomes.id"), nullable=False)

    # --- Attributs de la Relation ---
    probabilite = Column(DECIMAL(5, 4), comment="Probabilité d'apparition du symptôme pour cette pathologie P(symptôme|pathologie)")
    sensibilite = Column(DECIMAL(5, 4))
    specificite = Column(DECIMAL(5, 4))
    phase_maladie = Column(String(50), comment="Phase de la maladie où le symptôme apparaît (ex: Précoce, Tardive)")
    frequence = Column(String(50), comment="Fréquence d'apparition (ex: Constant, Fréquent, Occasionnel)")
    est_pathognomonique = Column(Boolean, default=False, comment="Si True, ce symptôme seul suffit presque à poser le diagnostic")
    importance_diagnostique = Column(Integer, comment="Échelle de 1 à 5 sur l'importance de ce symptôme pour le diagnostic")

    # --- Relations Inverses (Back-population) ---
    # Permet d'accéder à l'objet parent directement depuis une instance de cette classe.
    # ex: mon_association.pathologie -> renvoie l'objet Disease
    pathologie = relationship("Disease", back_populates="symptomes")
    symptome = relationship("Symptom", back_populates="pathologies")

    def __repr__(self) -> str:
        return f"<PathologieSymptome(pathologie_id={self.pathologie_id}, symptome_id={self.symptome_id})>"
    

# Contenu à AJOUTER à la fin de app/models/relations.py

class TraitementPathologie(Base):
    """
    Table d'association pour les traitements spécifiques aux pathologies.
    """
    __tablename__ = "traitements_pathologies"

    id = Column(Integer, primary_key=True)
    pathologie_id = Column(Integer, ForeignKey("pathologies.id"), nullable=False)
    medicament_id = Column(Integer, ForeignKey("medicaments.id"), nullable=False)

    type_traitement = Column(String(50), comment="Ex: Premiere_intention, Alternative, Adjuvant")
    ligne_traitement = Column(Integer, comment="Ex: 1ère ligne, 2e ligne")
    indication_precise = Column(Text)
    efficacite_taux = Column(DECIMAL(5, 2), comment="Taux de succès en %")
    duree_traitement_jours = Column(Integer)
    posologie_detaillee = Column(JSON)
    niveau_preuve = Column(String(50), comment="Grade de recommandation (A, B, C)")
    guidelines_source = Column(String(255), comment="Source (OMS, MINSANTE Cameroun, etc.)")
    rang_preference = Column(Integer, default=99)

    pathologie = relationship("Disease", back_populates="traitements")
    medicament = relationship("Medication", back_populates="traitements_pathologies")


class TraitementSymptome(Base):
    """
    Table d'association pour les traitements symptomatiques.
    """
    __tablename__ = "traitements_symptomes"

    id = Column(Integer, primary_key=True)
    symptome_id = Column(Integer, ForeignKey("symptomes.id"), nullable=False)
    medicament_id = Column(Integer, ForeignKey("medicaments.id"), nullable=False)

    efficacite = Column(String(50), comment="Ex: Tres_efficace, Efficace, Modere")
    rapidite_action = Column(String(100), comment="Ex: Immediate, <30min")
    posologie_recommandee = Column(Text)
    rang_preference = Column(Integer, default=99)
    
    symptome = relationship("Symptom", back_populates="traitements")
    medicament = relationship("Medication", back_populates="traitements_symptomes")




=== Fichier: ./tracking_models.py ===

from sqlalchemy import Column, Integer, String, Float, ForeignKey, JSON, TIMESTAMP, text, Boolean, Text
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
import uuid
from .base import Base

class SimulationSession(Base):
    __tablename__ = "simulation_sessions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    learner_id = Column(Integer, ForeignKey("learners.id"), nullable=False)
    cas_clinique_id = Column(Integer, ForeignKey("cas_cliniques_enrichis.id"), nullable=False)
    
    start_time = Column(TIMESTAMP, server_default=text("now()"))
    end_time = Column(TIMESTAMP)
    score_final = Column(Float)
    temps_total = Column(Integer)
    cout_virtuel_genere = Column(Integer)
    statut = Column(String(50), default="en_cours")
    raison_fin = Column(String(100))
    current_stage = Column(String(50))
    context_state = Column(JSON)

    learner = relationship("Learner", back_populates="sessions")
    cas_clinique = relationship("ClinicalCase")
    
    # --- Relations ---
    messages = relationship("ChatMessage", back_populates="session", cascade="all, delete-orphan")
    tutor_decisions = relationship("TutorDecision", back_populates="session")
    
    # --- RELATION VERS INTERACTION LOG CORRIGÉE ET ACTIVÉE ---
    logs = relationship("InteractionLog", back_populates="session", cascade="all, delete-orphan")
    # ----------------------------------------------------

class ChatMessage(Base):
    __tablename__ = "chat_messages"

    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"), nullable=False)
    
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    sender = Column(String(50), nullable=False) # student, patient, tutor
    content = Column(Text, nullable=False)
    
    # Suppression des champs qui n'existent plus dans la migration la plus récente
    # intention_detectee = Column(String(100))
    # sentiment_analyse = Column(String(50))
    message_metadata = Column(JSON)

    session = relationship("SimulationSession", back_populates="messages")


# === CLASSE 'InteractionLog' AJOUTÉE ===
# Ce modèle manquait, ce qui causait l'ImportError.
class InteractionLog(Base):
    __tablename__ = "interaction_logs"

    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    action_category = Column(String(50))
    action_type = Column(String(100))
    action_content = Column(JSON)
    response_latency = Column(Integer)
    charge_cognitive_estimee = Column(Float)
    est_pertinent = Column(Boolean)

    session = relationship("SimulationSession", back_populates="logs")


# === CLASSE 'LearnerAffectiveState' AJOUTÉE ===
# Ce modèle était également importé dans __init__.py mais manquant dans ce fichier.
class LearnerAffectiveState(Base):
    __tablename__ = "learner_affective_states"

    id = Column(Integer, primary_key=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    stress_level = Column(Float)
    confidence_level = Column(Float)
    motivation_level = Column(Float)
    frustration_level = Column(Float)

    session = relationship("SimulationSession")

=== Fichier: ./prerequisite.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    ForeignKey,
    DECIMAL,
    text
)
from sqlalchemy.orm import relationship

from .base import Base


class Competence(Base):
    """
    Modèle SQLAlchemy pour les compétences cliniques (Knowledge Components).
    """
    __tablename__ = "competences_cliniques"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification ---
    code_competence = Column(String(50), unique=True, nullable=False, index=True, comment="Code unique (ex: 'ANAMNESE_DOULEUR')")
    nom = Column(String(255), nullable=False)
    categorie = Column(String(100), index=True, comment="Ex: Anamnese, Examen_physique, Raisonnement, Technique")
    
    # --- Pédagogie ---
    niveau_bloom = Column(Integer, comment="Niveau dans la taxonomie de Bloom (1-6)")
    description = Column(Text)
    objectifs_apprentissage = Column(JSON, comment="Liste détaillée des objectifs")
    criteres_maitrise = Column(JSON, comment="Critères pour valider la compétence")
    
    # --- Hiérarchie (Parent/Enfant) ---
    parent_competence_id = Column(Integer, ForeignKey("competences_cliniques.id"), nullable=True)
    ordre_apprentissage = Column(Integer, default=0)

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))

    # --- Relations ---
    children = relationship("Competence", 
                          back_populates="parent",
                          cascade="all, delete-orphan")
    
    parent = relationship("Competence", 
                        back_populates="children",
                        remote_side=[id])

    # Relation vers les prérequis
    prerequis = relationship(
        "Competence",
        secondary="prerequis_competences",
        primaryjoin="Competence.id==prerequis_competences.c.competence_id",
        secondaryjoin="Competence.id==prerequis_competences.c.prerequis_id",
        backref="est_prerequis_pour"
    )

    def __repr__(self) -> str:
        return f"<Competence(code='{self.code_competence}', nom='{self.nom}')>"


class PrerequisCompetence(Base):
    """
    Table d'association pour le graphe de prérequis entre compétences.
    Permet de dire : "Pour apprendre A, il faut d'abord maîtriser B".
    """
    __tablename__ = "prerequis_competences"

    id = Column(Integer, primary_key=True)
    
    # La compétence cible (Celle qu'on veut apprendre)
    competence_id = Column(Integer, ForeignKey("competences_cliniques.id"), nullable=False)
    
    # La compétence prérequise (Celle qu'on doit déjà avoir)
    prerequis_id = Column(Integer, ForeignKey("competences_cliniques.id"), nullable=False)
    
    # --- Métadonnées de la relation ---
    type_relation = Column(String(50), default="STRICT", comment="STRICT, RECOMMANDE, SUPPORTIF")
    force_relation = Column(DECIMAL(3, 2), default=1.0, comment="Force du lien (0-1)")

    def __repr__(self) -> str:
        return f"<Prerequis(target={self.competence_id}, needed={self.prerequis_id})>"

=== Fichier: ./__init__.py ===

# ==============================================================================
# FICHIER D'INITIALISATION DU PACKAGE 'models'
# ------------------------------------------------------------------------------
# Ce fichier centralise l'importation de toutes les classes de modèles SQLAlchemy,
# les rendant facilement accessibles depuis le reste de l'application via
# l'import `from app import models`.
# ==============================================================================

# --- Modèle de Base ---
from .base import Base

# --- Modèles du Domaine Expert ---
from .symptom import Symptom
from .disease import Disease
from .medication import Medication
from .media import ImageMedicale
from .clinical_case import ClinicalCase
from .expert_strategy import ExpertStrategy
from .relations import PathologieSymptome, TraitementPathologie, TraitementSymptome
from .prerequisite import Competence, PrerequisCompetence
from .expert_user import ExpertUser

# --- Modèles de l'Apprenant ---
from .learner_models import (
    Learner,
    LearnerCompetencyMastery,
    LearnerCognitiveProfile,
    LearnerMisconception,
    LearnerGoal,
    LearnerPreference,
    LearnerAchievement,
    LearnerStrategy
)

# --- Modèles de Suivi (Tracking) ---
from .tracking_models import (
    SimulationSession,
    ChatMessage,
    # La ligne ci-dessous est la correction clé pour l'erreur actuelle
    InteractionLog,
    LearnerAffectiveState
)

# --- Modèles du Tuteur ---
from .tutor_models import (
    LearningPath,
    TutorDecision,
    TutorStrategiesHistory,
    TutorScaffoldingState,
    TutorSocraticState,
    TutorMotivationalState,
    TutorFeedbackLog
)

# ==============================================================================
# FIN DU FICHIER
# ==============================================================================

=== Fichier: ./expert_user.py ===

from sqlalchemy import Column, Integer, String, Text, Boolean, TIMESTAMP, text
from sqlalchemy.orm import relationship
from .base import Base

class ExpertUser(Base):
    __tablename__ = "experts"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    nom_complet = Column(String(255))
    specialite = Column(String(100))
    hopital_affiliation = Column(String(255))
    role = Column(String(50), default="validateur") # superadmin, validateur, contributeur
    
    last_login = Column(TIMESTAMP)
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))

    # Relation avec les cas cliniques validés
    cas_valides = relationship("ClinicalCase", back_populates="expert_validateur")

=== Fichier: ./expert_strategy.py ===

from sqlalchemy import (
    DECIMAL,
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    Boolean,
    Date,
    text
)
from sqlalchemy.orm import relationship

from .base import Base


class ExpertStrategy(Base):
    """
    Modèle SQLAlchemy pour la table des règles de production (stratégies expertes).
    
    Cette table stocke la logique IF-THEN du système expert.
    """
    __tablename__ = "regles_production"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification et Métadonnées ---
    code_regle = Column(String(50), unique=True, nullable=False, index=True)
    categorie = Column(String(100), index=True, comment="Ex: DIAGNOSTIC, THERAPEUTIQUE, PEDAGOGIQUE, ALERTE")
    priorite = Column(Integer, default=5, comment="Priorité d'exécution (1-10), 10 étant le plus prioritaire")
    
    # --- Structure de la Règle (IF-THEN) ---
    conditions = Column(JSON, nullable=False, comment="Partie 'IF' de la règle, structurée en JSON")
    # Exemple de 'conditions':
    # {
    #   "operator": "AND",
    #   "rules": [
    #     {"fact": "symptom", "value": "Fièvre", "operator": "present"},
    #     {"fact": "symptom", "value": "Toux", "operator": "present"},
    #     {"fact": "age", "value": 65, "operator": "greater_than"}
    #   ]
    # }

    actions = Column(JSON, nullable=False, comment="Partie 'THEN' de la règle, structurée en JSON")
    # Exemple d' 'actions':
    # [
    #   {"action": "add_hypothesis", "pathology": "Pneumonie", "confidence": 0.8},
    #   {"action": "recommend_exam", "exam": "Radio Thorax", "urgency": "high"}
    # ]

    # --- Documentation et Validation ---
    description_naturelle = Column(Text, comment="Description de la règle en langage naturel")
    justification_medicale = Column(Text, comment="Source ou justification clinique de la règle")
    expert_auteur = Column(String(255))
    date_validation = Column(Date)
    est_active = Column(Boolean, default=True, nullable=False)

    # --- Métriques ---
    nb_activations = Column(Integer, default=0)
    taux_succes = Column(DECIMAL(5, 4))

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    def __repr__(self) -> str:
        return f"<ExpertStrategy(id={self.id}, code='{self.code_regle}')>"

=== Fichier: ./media.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    Boolean,
    Date,
    ForeignKey,
    text
)
from sqlalchemy.orm import relationship
from pgvector.sqlalchemy import Vector

from .base import Base


class ImageMedicale(Base):
    """
    Modèle SQLAlchemy pour la table des images médicales.
    Catalogue toutes les images (radios, scanners, etc.) avec leurs métadonnées.
    """
    __tablename__ = "images_medicales"

    id = Column(Integer, primary_key=True, index=True)

    # --- Classification et Liaison ---
    type_examen = Column(String(100), nullable=False, index=True, comment="Ex: Radiographie, Échographie, Scanner")
    sous_type = Column(String(100), comment="Ex: Thorax, Abdomen, Crâne")
    pathologie_id = Column(Integer, ForeignKey("pathologies.id"), nullable=True, index=True)

    # --- Gestion du Fichier ---
    fichier_url = Column(String(500), nullable=False, comment="URL vers le fichier (S3, stockage local, etc.)")
    fichier_miniature_url = Column(String(500), comment="URL vers une version miniature de l'image")
    format_image = Column(String(20), comment="Ex: DICOM, PNG, JPEG")
    taille_ko = Column(Integer)
    resolution = Column(String(50))

    # --- Métadonnées Cliniques ---
    description = Column(Text, comment="Description générale de l'image ou du cas")
    signes_radiologiques = Column(JSON, comment="Signes spécifiques visibles (ex: opacité, épanchement)")
    annotations = Column(JSON, comment="Coordonnées et descriptions de zones d'intérêt")
    interpretation_experte = Column(Text, comment="Compte-rendu d'un radiologue expert")
    diagnostic_differentiel = Column(JSON, comment="Autres diagnostics possibles basés sur l'image")

    # --- Métadonnées Pédagogiques ---
    niveau_difficulte = Column(Integer, comment="Difficulté d'interprétation de l'image (1-5)")
    qualite_image = Column(Integer, comment="Qualité technique de l'image (1-5)")

    # --- Intelligence Artificielle ---
    embedding_vision = Column(Vector(384), nullable=True, comment="Vecteur d'embedding pour la recherche par similarité visuelle")

    # --- Validation et Horodatage ---
    valide_expert = Column(Boolean, default=False)
    expert_validateur = Column(String(255))
    date_validation = Column(Date)
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))

    # --- Relations ---
    # Permet d'accéder à l'objet Pathologie depuis une ImageMedicale
    pathologie = relationship("Disease") # Nous n'avons pas besoin de back_populates ici pour l'instant

    def __repr__(self) -> str:
        return f"<ImageMedicale(id={self.id}, type='{self.type_examen}')>"


=== Fichier: ./knowledge_version.py ===



=== Fichier: ./disease.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    DECIMAL,
    text
)
from sqlalchemy.orm import relationship
from pgvector.sqlalchemy import Vector

from .base import Base


class Disease(Base):
    """
    Modèle SQLAlchemy pour la table des pathologies (maladies).

    Cette table contient toutes les informations détaillées sur chaque maladie
    connue par le système, y compris le contexte local, les caractéristiques
    cliniques et les vecteurs pour l'IA.
    """
    __tablename__ = "pathologies"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification et Classification ---
    code_icd10 = Column(String(20), unique=True, index=True, comment="Code international de la maladie (CIM-10)")
    nom_fr = Column(String(255), nullable=False, index=True)
    nom_en = Column(String(255))
    nom_local = Column(String(255), comment="Noms locaux ou courants au Cameroun")
    categorie = Column(String(100), index=True, comment="Ex: Infectieuse, Chronique, Parasitaire")

    # --- Données Cliniques et Épidémiologiques ---
    prevalence_cameroun = Column(DECIMAL(5, 2), comment="Prévalence en % dans le contexte camerounais")
    niveau_gravite = Column(Integer, comment="Échelle de 1 (bénin) à 5 (critique)")
    description = Column(Text)
    physiopathologie = Column(Text, comment="Mécanisme de la maladie")
    evolution_naturelle = Column(Text, comment="Comment la maladie évolue sans traitement")
    complications = Column(JSON, comment="Complications possibles")
    facteurs_risque = Column(JSON, comment="Facteurs de risque associés")
    prevention = Column(Text, comment="Mesures de prévention")

    # --- Intelligence Artificielle ---
    embedding_vector = Column(Vector(384), nullable=True, comment="Vecteur d'embedding pour la recherche sémantique")

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    # --- Relations ---
    # Nous préparons le terrain pour la future relation avec les symptômes.
    # Pour l'instant, elle reste en commentaire pour éviter les erreurs d'import circulaire.
    symptomes = relationship(
         "PathologieSymptome",
         back_populates="pathologie",
         cascade="all, delete-orphan"
    
     )
    
    traitements = relationship(
        "TraitementPathologie",
        back_populates="pathologie",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Disease(id={self.id}, nom_fr='{self.nom_fr}')>"

=== Fichier: ./diagnostic.py ===



=== Fichier: ./base.py ===

from sqlalchemy.orm import declarative_base

# Cette instance de 'declarative_base' est le catalogue central où SQLAlchemy
# enregistrera toutes les classes de modèles que nous définirons.
# C'est ce que Alembic utilisera pour comparer l'état de notre code
# avec l'état de la base de données.
Base = declarative_base()

