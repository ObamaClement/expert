=== Fichier: ./main.py ===

from fastapi import FastAPI
from .api.v1 import (
    symptoms, diseases, medications, media, clinical_cases, 
    expert_strategies, diagnostic, chat, simulation
)
# --- AJOUT ---
from .utils.logging import setup_logging

# Configurer le logging dès le démarrage
setup_logging()
# --- FIN AJOUT ---

app = FastAPI(
    title="STI Medical Expert Module",
    description="Base de connaissances et moteur de raisonnement pour le STI médical.",
    version="0.1.0"
)

# ... (le reste de vos `app.include_router` reste identique)
app.include_router(symptoms.router, prefix="/api/v1")
app.include_router(diseases.router, prefix="/api/v1")
app.include_router(medications.router, prefix="/api/v1")
app.include_router(media.router, prefix="/api/v1")
app.include_router(clinical_cases.router, prefix="/api/v1")
app.include_router(expert_strategies.router, prefix="/api/v1")
app.include_router(diagnostic.router, prefix="/api/v1")
app.include_router(chat.router, prefix="/api/v1")
app.include_router(simulation.router, prefix="/api/v1")

@app.get("/")
def read_root():
    return {"status": "Service is running"}

=== Fichier: ./core/cognitive_diagnosis.py ===



=== Fichier: ./core/prerequisite_graph.py ===



=== Fichier: ./core/htn_planner.py ===



=== Fichier: ./core/integrity_validator.py ===



=== Fichier: ./core/__init__.py ===



=== Fichier: ./core/q_matrix_solver.py ===



=== Fichier: ./core/reasoning_engine.py ===

from typing import List, Dict, Any

def evaluate_condition(condition: Dict[str, Any], facts: Dict[str, Any]) -> bool:
    """
    Évalue une seule condition par rapport à un ensemble de faits.
    Version très simple pour commencer.
    """
    fact_type = condition.get("fact")
    fact_value = condition.get("value")
    operator = condition.get("operator")

    if fact_type == "symptom" and operator == "present":
        return fact_value in facts.get("symptoms", [])
    
    if fact_type == "context" and operator == "is":
        return fact_value in facts.get("context", [])
    
    # Ajouter d'autres logiques d'évaluation ici plus tard (ex: age > 65)
    
    return False


def forward_chaining_engine(rules: List[Dict[str, Any]], facts: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Moteur de raisonnement simple en chaînage avant.

    :param rules: Une liste de règles, où chaque règle est un dictionnaire
                  avec les clés 'conditions' et 'actions'.
    :param facts: Un dictionnaire représentant les faits connus sur le patient
                  (ex: {"symptoms": ["Fièvre", "Toux"], "context": ["zone_endemique"]}).
    :return: Une liste de toutes les actions des règles qui ont été déclenchées.
    """
    triggered_actions = []

    for rule in rules:
        conditions = rule.get("conditions", {})
        
        # Pour l'instant, nous ne gérons que l'opérateur "AND"
        if conditions.get("operator") == "AND":
            all_conditions_met = True
            for condition in conditions.get("rules", []):
                if not evaluate_condition(condition, facts):
                    all_conditions_met = False
                    break  # Inutile de vérifier les autres conditions de cette règle
            
            if all_conditions_met:
                # Toutes les conditions sont remplies, on ajoute les actions
                triggered_actions.extend(rule.get("actions", []))

    return triggered_actions

"""""
# Ajoutez ce bloc à la fin du fichier pour tester
if __name__ == "__main__":
    # Définir une règle de test (copiée de notre exemple précédent)
    test_rule = {
        "code_regle": "DIAG_PALU_SIMPLE_01",
        "conditions": {
            "operator": "AND",
            "rules": [
                {"fact": "symptom", "value": "Fièvre", "operator": "present"},
                {"fact": "context", "value": "zone_endemique", "operator": "is"}
            ]
        },
        "actions": [
            {"action": "add_hypothesis", "pathology": "Paludisme simple", "confidence": 0.7}
        ]
    }
    
    # Définir des faits qui devraient déclencher la règle
    patient_facts = {
        "symptoms": ["Fièvre", "Toux"],
        "context": ["zone_endemique"]
    }
    
    print("Test du moteur de raisonnement...")
    conclusions = forward_chaining_engine(rules=[test_rule], facts=patient_facts)
    
    print(f"Faits: {patient_facts}")
    print(f"Règles: {[test_rule['code_regle']]}")
    print(f"Conclusions: {conclusions}")
    
    # Vérification du test
    assert len(conclusions) == 1
    assert conclusions[0]['pathology'] == 'Paludisme simple'
    print("\n✅ Test réussi !")
    
    """

=== Fichier: ./core/knowledge_graph.py ===



=== Fichier: ./ml/embeddings.py ===



=== Fichier: ./ml/__init__.py ===



=== Fichier: ./ml/clustering.py ===



=== Fichier: ./ml/recommendation.py ===



=== Fichier: ./ml/similarity.py ===



=== Fichier: ./schemas/symptom.py ===

from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from datetime import datetime

# ==============================================================================
# Schéma de Base
# ==============================================================================
class SymptomBase(BaseModel):
    """
    Schéma de base pour un symptôme.
    Contient les champs communs à la création et à la lecture.
    """
    nom: str
    nom_local: Optional[str] = None
    categorie: Optional[str] = None
    type_symptome: Optional[str] = None
    description: Optional[str] = None
    questions_anamnese: Optional[Dict[str, Any]] = None
    signes_alarme: bool = False


# ==============================================================================
# Schéma pour la Création (ce que l'API attend dans un POST)
# ==============================================================================
class SymptomCreate(SymptomBase):
    """
    Schéma utilisé pour créer un nouveau symptôme via l'API.
    Hérite de SymptomBase et n'ajoute aucun champ supplémentaire pour l'instant.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour (ce que l'API attend dans un PATCH)
# ==============================================================================
class SymptomUpdate(BaseModel):
    """
    Schéma utilisé pour mettre à jour un symptôme existant.
    Tous les champs sont optionnels pour permettre des mises à jour partielles.
    """
    nom: Optional[str] = None
    nom_local: Optional[str] = None
    categorie: Optional[str] = None
    type_symptome: Optional[str] = None
    description: Optional[str] = None
    questions_anamnese: Optional[Dict[str, Any]] = None
    signes_alarme: Optional[bool] = None


# ==============================================================================
# Schéma pour la Lecture (ce que l'API renvoie)
# ==============================================================================
class Symptom(SymptomBase):
    """
    Schéma complet pour représenter un symptôme, y compris les champs
    générés par la base de données comme 'id' et 'created_at'.
    Ce sera le modèle de réponse de l'API.
    """
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        """
        Configuration pour Pydantic.
        'from_attributes = True' (anciennement 'orm_mode') permet au modèle Pydantic
        de lire les données directement depuis un objet SQLAlchemy.
        C'est le lien magique entre notre modèle de BDD et notre schéma d'API.
        """
        from_attributes = True

=== Fichier: ./schemas/medication.py ===

from pydantic import BaseModel
from typing import Optional, Dict, Any
from datetime import datetime

# ==============================================================================
# Schéma de Base
# ==============================================================================
class MedicationBase(BaseModel):
    """
    Schéma de base pour un médicament, contenant les champs modifiables.
    """
    dci: str
    nom_commercial: Optional[str] = None
    classe_therapeutique: Optional[str] = None
    forme_galenique: Optional[str] = None
    dosage: Optional[str] = None
    voie_administration: Optional[str] = None
    mecanisme_action: Optional[str] = None
    indications: Optional[Dict[str, Any]] = None
    contre_indications: Optional[Dict[str, Any]] = None
    effets_secondaires: Optional[Dict[str, Any]] = None
    interactions_medicamenteuses: Optional[Dict[str, Any]] = None
    precautions_emploi: Optional[str] = None
    posologie_standard: Optional[Dict[str, Any]] = None
    disponibilite_cameroun: Optional[str] = None
    cout_moyen_fcfa: Optional[int] = None
    statut_prescription: Optional[str] = None


# ==============================================================================
# Schéma pour la Création
# ==============================================================================
class MedicationCreate(MedicationBase):
    """
    Schéma utilisé pour créer un nouveau médicament.
    'dci' est le seul champ strictement requis.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour
# ==============================================================================
class MedicationUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle d'un médicament.
    """
    dci: Optional[str] = None
    nom_commercial: Optional[str] = None
    classe_therapeutique: Optional[str] = None
    # ... (tous les autres champs de MedicationBase en optionnel)
    forme_galenique: Optional[str] = None
    dosage: Optional[str] = None
    voie_administration: Optional[str] = None
    mecanisme_action: Optional[str] = None
    indications: Optional[Dict[str, Any]] = None
    contre_indications: Optional[Dict[str, Any]] = None
    effets_secondaires: Optional[Dict[str, Any]] = None
    interactions_medicamenteuses: Optional[Dict[str, Any]] = None
    precautions_emploi: Optional[str] = None
    posologie_standard: Optional[Dict[str, Any]] = None
    disponibilite_cameroun: Optional[str] = None
    cout_moyen_fcfa: Optional[int] = None
    statut_prescription: Optional[str] = None


# ==============================================================================
# Schéma pour la Lecture (Réponse API)
# ==============================================================================
class Medication(MedicationBase):
    """
    Schéma complet pour représenter un médicament en réponse d'API.
    """
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

=== Fichier: ./schemas/clinical_case.py ===

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime, date
from decimal import Decimal

# Importer les autres schémas pour les réponses imbriquées
from .disease import Disease
from .media import ImageMedicale
from .symptom import Symptom






# --- NOUVEAUX SOUS-SCHÉMAS ---
class SymptomInCase(BaseModel):
    symptome_id: int
    details: str # Ex: "Fièvre élevée (40°C) apparue brutalement il y a 48h"

class PresentationClinique(BaseModel):
    histoire_maladie: str
    symptomes_patient: List[SymptomInCase]
    antecedents: Optional[Dict[str, Any]] = None
# ==============================================================================
# Schéma de Base et de Création
# ==============================================================================
class ClinicalCaseBase(BaseModel):
    """
    Schéma de base pour un cas clinique, contenant les champs éditables.
    """
    code_fultang: str = Field(..., description="Identifiant unique (Fultang ou synthétique)")
    pathologie_principale_id: Optional[int] = None
    pathologies_secondaires_ids: Optional[List[int]] = []
    presentation_clinique: PresentationClinique
    donnees_paracliniques: Optional[Dict[str, Any]] = None
    evolution_patient: Optional[str] = None
    images_associees_ids: Optional[List[int]] = []
    sons_associes_ids: Optional[List[int]] = []
    medicaments_prescrits: Optional[List[Dict[str, Any]]] = []
    niveau_difficulte: int = Field(default=3, ge=1, le=101)
    duree_estimee_resolution_min: Optional[int] = None
    objectifs_apprentissage: Optional[List[str]] = []
    competences_requises: Optional[Dict[str, Any]] = {}


class ClinicalCaseCreate(ClinicalCaseBase):
    """
    Schéma utilisé pour créer un nouveau cas clinique via l'API.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour
# ==============================================================================
class ClinicalCaseUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle d'un cas clinique.
    """
    code_fultang: Optional[str] = None
    pathologie_principale_id: Optional[int] = None
    presentation_clinique: Optional[Dict[str, Any]] = None
    donnees_paracliniques: Optional[Dict[str, Any]] = None
    evolution_patient: Optional[str] = None
    images_associees_ids: Optional[List[int]] = None
    sons_associes_ids: Optional[List[int]] = None
    medicaments_prescrits: Optional[List[Dict[str, Any]]] = None
    niveau_difficulte: Optional[int] = Field(None, ge=1, le=101)
    duree_estimee_resolution_min: Optional[int] = None
    objectifs_apprentissage: Optional[List[str]] = None
    competences_requises: Optional[Dict[str, Any]] = None
    valide_expert: Optional[bool] = None
    expert_validateur: Optional[str] = None
    date_validation: Optional[date] = None


# ==============================================================================
# Schémas pour la Lecture (Réponse API)
# ==============================================================================
class ClinicalCaseSimple(BaseModel):
    """
    Schéma simplifié pour les listes de cas cliniques.
    """
    id: int
    code_fultang: str
    niveau_difficulte: int
    pathologie_principale: Optional[Disease] = None # Affiche l'objet maladie complet
    nb_images: int
    nb_sons: int

    class Config:
        from_attributes = True


# --- NOUVEAU SCHÉMA DE LECTURE ENRICHI ---
class SymptomDetailInCase(BaseModel):
    symptome: Symptom # L'objet symptôme complet
    details: str # Les détails spécifiques au cas

class PresentationCliniqueDetail(BaseModel):
    histoire_maladie: str
    symptomes_patient: List[SymptomDetailInCase]
    antecedents: Optional[Dict[str, Any]] = None


class ClinicalCase(ClinicalCaseBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    pathologie_principale: Optional[Disease] = None
    pathologies_secondaires: List[Disease] = [] # <- AJOUTER
    images_associees: List[ImageMedicale] = []
    
    # --- ENRICHISSEMENT DE LA PRÉSENTATION CLINIQUE ---
    presentation_clinique_detail: Optional[PresentationCliniqueDetail] = None

    class Config:
        from_attributes = True



=== Fichier: ./schemas/relations.py ===

from pydantic import BaseModel, Field
from typing import Any, Dict, Optional
from decimal import Decimal

# Importer les schémas de base pour l'affichage
from .symptom import Symptom
from .disease import Disease
from .medication import Medication


# ==============================================================================
# Schéma de Base et de Création pour l'Association
# ==============================================================================
class PathologieSymptomeBase(BaseModel):
    """
    Schéma de base pour l'association Pathologie-Symptôme.
    Contient les champs nécessaires pour créer ou mettre à jour le lien.
    """
    pathologie_id: int
    symptome_id: int
    probabilite: Optional[Decimal] = Field(None, ge=0, le=1)
    sensibilite: Optional[Decimal] = Field(None, ge=0, le=1)
    specificite: Optional[Decimal] = Field(None, ge=0, le=1)
    phase_maladie: Optional[str] = None
    frequence: Optional[str] = None
    est_pathognomonique: bool = False
    importance_diagnostique: Optional[int] = Field(None, ge=1, le=5)

class PathologieSymptomeCreate(PathologieSymptomeBase):
    """
    Schéma utilisé spécifiquement pour créer une nouvelle association.
    """
    pass


# ==============================================================================
# Schémas pour la Lecture (Réponse de l'API)
# ==============================================================================
class PathologieSymptome(PathologieSymptomeBase):
    """
    Schéma complet pour la réponse de l'API, incluant l'ID de l'association.
    """
    id: int

    class Config:
        from_attributes = True


class SymptomForDiseaseDetail(BaseModel):
    """
    Schéma pour afficher les détails d'un symptôme DANS le contexte d'une pathologie.
    """
    symptome: Symptom
    probabilite: Optional[Decimal]
    importance_diagnostique: Optional[int]
    est_pathognomonique: bool

    class Config:
        from_attributes = True


class DiseaseForSymptomDetail(BaseModel):
    """
    Schéma pour afficher les détails d'une pathologie DANS le contexte d'un symptôme
    (utile pour le diagnostic différentiel).
    """
    pathologie: Disease
    probabilite: Optional[Decimal]
    importance_diagnostique: Optional[int]

    class Config:
        from_attributes = True



# Contenu à AJOUTER à la fin de app/schemas/relations.py

# Importer le schéma de base pour l'affichage


# ==============================================================================
# Schémas pour l'Association Traitement-Pathologie
# ==============================================================================
class TraitementPathologieBase(BaseModel):
    pathologie_id: int
    medicament_id: int
    type_traitement: Optional[str] = None
    ligne_traitement: Optional[int] = None
    indication_precise: Optional[str] = None
    efficacite_taux: Optional[Decimal] = Field(None, ge=0, le=100)
    duree_traitement_jours: Optional[int] = None
    posologie_detaillee: Optional[Dict[str, Any]] = None
    niveau_preuve: Optional[str] = None
    guidelines_source: Optional[str] = None
    rang_preference: Optional[int] = 99

class TraitementPathologieCreate(TraitementPathologieBase):
    pass

class TraitementPathologie(TraitementPathologieBase):
    id: int
    class Config:
        from_attributes = True

class MedicationForDiseaseDetail(BaseModel):
    """
    Schéma pour afficher les détails d'un médicament DANS le contexte d'une pathologie.
    """
    medicament: Medication
    type_traitement: Optional[str]
    ligne_traitement: Optional[int]
    rang_preference: Optional[int]
    
    class Config:
        from_attributes = True

# ==============================================================================
# Schémas pour l'Association Traitement-Symptôme
# ==============================================================================
class TraitementSymptomeBase(BaseModel):
    symptome_id: int
    medicament_id: int
    efficacite: Optional[str] = None
    rapidite_action: Optional[str] = None
    posologie_recommandee: Optional[str] = None
    rang_preference: Optional[int] = 99

class TraitementSymptomeCreate(TraitementSymptomeBase):
    pass

class TraitementSymptome(TraitementSymptomeBase):
    id: int
    class Config:
        from_attributes = True

class MedicationForSymptomDetail(BaseModel):
    """
    Schéma pour afficher les détails d'un médicament DANS le contexte d'un symptôme.
    """
    medicament: Medication
    efficacite: Optional[str]
    rang_preference: Optional[int]

    class Config:
        from_attributes = True

=== Fichier: ./schemas/tracking_models.py ===



=== Fichier: ./schemas/__init__.py ===

# ==============================================================================
# FICHIER D'INITIALISATION DU PACKAGE 'schemas'
# ------------------------------------------------------------------------------
# Ce fichier a deux rôles principaux :
# 1. Il signale à Python que le dossier 'schemas' est un "package", c'est-à-dire
#    un ensemble de modules qui peuvent être importés.
# 2. Il définit ce qui est accessible publiquement lorsque l'on importe 'schemas'.
#    C'est le "hall d'entrée" du package.
# ==============================================================================

# --- IMPORTS EXISTANTS (validés) ---
# Chaque ligne rend des classes spécifiques directement accessibles
# depuis le package 'schemas'.
# Exemple : `from app import schemas` puis `schemas.Symptom`

from .symptom import SymptomCreate, SymptomBase, SymptomUpdate, Symptom
from .disease import DiseaseCreate, DiseaseBase, DiseaseUpdate, Disease
from .medication import MedicationCreate, MedicationBase, MedicationUpdate, Medication
from .media import ImageMedicaleBase, ImageMedicaleUpdate, ImageMedicale
from .clinical_case import ClinicalCaseCreate, ClinicalCaseBase, ClinicalCaseUpdate, ClinicalCase
from .expert_strategy import ExpertStrategyCreate, ExpertStrategyBase, ExpertStrategyUpdate, ExpertStrategy

# --- NOUVEAUX IMPORTS (pour corriger les erreurs) ---

# 1. CORRECTION POUR 'chat_message'
# Cette ligne importe les classes `ChatMessage` et `ChatMessageCreate` depuis le
# fichier `chat_message.py`. Sans cela, l'erreur `AttributeError: module 'app.schemas'
# has no attribute 'ChatMessageCreate'` se produit.
from .chat_message import ChatMessage, ChatMessageCreate

# 2. IMPORTATION DES MODULES COMPLETS
# Pour les schémas complexes comme 'relations' et 'simulation', il est souvent
# plus propre d'importer le module entier.
# Cela signifie qu'on y accédera avec une syntaxe comme `schemas.simulation.SessionStartRequest`.
# C'est ce que nous avons déjà fait dans le code des services.

# Rend le module 'relations.py' accessible via `schemas.relations`
from . import relations

# Rend le module 'simulation.py' accessible via `schemas.simulation`.
# C'est cette ligne qui a corrigé la première erreur `AttributeError` que vous aviez.
from . import simulation

# ==============================================================================
# FIN DU FICHIER
# ------------------------------------------------------------------------------
# Avec ce fichier, l'application sait maintenant où trouver TOUS les schémas
# Pydantic dont elle a besoin, que ce soit par import direct de classe
# (ex: schemas.Symptom) ou par import de module (ex: schemas.simulation.HintResponse).
# ==============================================================================

=== Fichier: ./schemas/simulation.py ===

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from uuid import UUID

from .clinical_case import ClinicalCase

# ==============================================================================
# SCHÉMAS POUR LE DÉMARRAGE D'UNE SESSION
# ==============================================================================

class SessionStartRequest(BaseModel):
    learner_id: int = Field(..., description="L'ID de l'apprenant qui commence la session.")
    category: str = Field(..., description="La catégorie de pathologie choisie (ex: 'Cardiologie').")

class SessionStartResponse(BaseModel):
    session_id: UUID = Field(..., description="L'ID unique de la session créée.")
    session_type: str = Field(..., description="Le type de session (test, formative, sommative).")
    clinical_case: ClinicalCase = Field(..., description="Les détails complets du cas clinique sélectionné.")

    class Config:
        from_attributes = True

# ==============================================================================
# SCHÉMAS POUR LES ACTIONS DE L'APPRENANT
# ==============================================================================

class LearnerActionRequest(BaseModel):
    action_type: str = Field(..., description="Le type d'action (ex: 'parametres_vitaux', 'examen_complementaire').")
    action_name: str = Field(..., description="Le nom spécifique de l'action (ex: 'Prise des constantes', 'NFS').")
    justification: Optional[str] = Field(None, description="La justification de l'apprenant pour cette action.")

class LearnerActionResponse(BaseModel):
    action_type: str
    action_name: str
    result: Dict[str, Any] = Field(..., description="Le résultat de l'action (ex: rapport et conclusion d'un examen).")
    feedback: Optional[str] = Field(None, description="Un feedback immédiat du tuteur sur la pertinence de l'action.")

# ==============================================================================
# SCHÉMA POUR LA RÉPONSE D'INDICE
# ==============================================================================

class HintResponse(BaseModel):
    hint_type: str = Field(..., description="Le type d'indice (ex: 'question_socratique', 'indice_direct').")
    content: str = Field(..., description="Le contenu textuel de l'indice.")

# ==============================================================================
# SCHÉMAS POUR LA SOUMISSION ET L'ÉVALUATION FINALE
# ==============================================================================

class SubmissionRequest(BaseModel):
    diagnosed_pathology_id: int = Field(..., description="L'ID de la pathologie principale diagnostiquée.")
    prescribed_medication_ids: List[int] = Field(default_factory=list, description="Liste des IDs des médicaments prescrits.")

class EvaluationResult(BaseModel):
    """
    Détaille les différentes composantes du score final, sur un total de 20 points.
    """
    score_diagnostic: float = Field(..., description="Score pour la justesse du diagnostic (sur 10).")
    score_therapeutique: float = Field(..., description="Score pour la pertinence du traitement (sur 5).")
    score_demarche: float = Field(..., description="Score pour la démarche clinique (sur 5).")
    score_total: float = Field(..., description="Score total sur 20.")

class SubmissionResponse(BaseModel):
    """
    Réponse de l'API après l'évaluation de la soumission de l'apprenant.
    """
    evaluation: EvaluationResult = Field(..., description="Le détail du score obtenu.")
    feedback_global: str = Field(..., description="Un commentaire global sur la performance.")
    recommendation_next_step: str = Field(..., description="Recommandation pour la suite du parcours.")

=== Fichier: ./schemas/expert_strategy.py ===

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime, date
from decimal import Decimal

# ==============================================================================
# Schéma de Base
# ==============================================================================
class ExpertStrategyBase(BaseModel):
    """
    Schéma de base pour une règle/stratégie experte.
    """
    code_regle: str = Field(..., max_length=50)
    categorie: str
    priorite: int = Field(default=5, ge=1, le=10)
    conditions: Dict[str, Any]
    actions: List[Dict[str, Any]]
    description_naturelle: Optional[str] = None
    justification_medicale: Optional[str] = None
    expert_auteur: Optional[str] = None
    date_validation: Optional[date] = None
    est_active: bool = True


# ==============================================================================
# Schéma pour la Création
# ==============================================================================
class ExpertStrategyCreate(ExpertStrategyBase):
    """
    Schéma utilisé pour créer une nouvelle règle.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour
# ==============================================================================
class ExpertStrategyUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle d'une règle.
    """
    code_regle: Optional[str] = Field(None, max_length=50)
    categorie: Optional[str] = None
    priorite: Optional[int] = Field(None, ge=1, le=10)
    conditions: Optional[Dict[str, Any]] = None
    actions: Optional[List[Dict[str, Any]]] = None
    description_naturelle: Optional[str] = None
    justification_medicale: Optional[str] = None
    expert_auteur: Optional[str] = None
    date_validation: Optional[date] = None
    est_active: Optional[bool] = None


# ==============================================================================
# Schéma pour la Lecture (Réponse API)
# ==============================================================================
class ExpertStrategy(ExpertStrategyBase):
    """
    Schéma complet pour représenter une règle en réponse d'API.
    """
    id: int
    nb_activations: int
    taux_succes: Optional[Decimal] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

=== Fichier: ./schemas/response.py ===



=== Fichier: ./schemas/media.py ===

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime, date

# ==============================================================================
# Schéma de Base pour les Métadonnées d'une Image
# ==============================================================================
class ImageMedicaleBase(BaseModel):
    """
    Schéma de base contenant les métadonnées modifiables d'une image médicale.
    """
    type_examen: str
    sous_type: Optional[str] = None
    pathologie_id: Optional[int] = None
    description: Optional[str] = None
    signes_radiologiques: Optional[Dict[str, Any]] = None
    annotations: Optional[List[Dict[str, Any]]] = None
    interpretation_experte: Optional[str] = None
    diagnostic_differentiel: Optional[List[str]] = None
    niveau_difficulte: Optional[int] = Field(None, ge=1, le=5)
    qualite_image: Optional[int] = Field(None, ge=1, le=5)
    valide_expert: Optional[bool] = False
    expert_validateur: Optional[str] = None
    date_validation: Optional[date] = None


# ==============================================================================
# Schéma pour la Mise à Jour des Métadonnées
# ==============================================================================
class ImageMedicaleUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle des métadonnées d'une image.
    Tous les champs sont optionnels.
    """
    type_examen: Optional[str] = None
    sous_type: Optional[str] = None
    pathologie_id: Optional[int] = None
    description: Optional[str] = None
    signes_radiologiques: Optional[Dict[str, Any]] = None
    annotations: Optional[List[Dict[str, Any]]] = None
    interpretation_experte: Optional[str] = None
    diagnostic_differentiel: Optional[List[str]] = None
    niveau_difficulte: Optional[int] = Field(None, ge=1, le=5)
    qualite_image: Optional[int] = Field(None, ge=1, le=5)
    valide_expert: Optional[bool] = None
    expert_validateur: Optional[str] = None
    date_validation: Optional[date] = None


# ==============================================================================
# Schéma pour la Lecture (Réponse API)
# ==============================================================================
class ImageMedicale(ImageMedicaleBase):
    """
    Schéma complet pour représenter les métadonnées d'une image en réponse d'API.
    """
    id: int
    fichier_url: str
    fichier_miniature_url: Optional[str] = None
    format_image: Optional[str] = None
    taille_ko: Optional[int] = None
    resolution: Optional[str] = None
    created_at: datetime

    class Config:
        from_attributes = True

# Nous ajouterons les schémas pour SonMedical ici plus tard.

=== Fichier: ./schemas/disease.py ===

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime
from decimal import Decimal

# ==============================================================================
# Schéma de Base
# ==============================================================================
class DiseaseBase(BaseModel):
    """
    Schéma de base pour une pathologie, contenant les champs modifiables.
    """
    nom_fr: str
    code_icd10: str
    nom_en: Optional[str] = None
    nom_local: Optional[str] = None
    categorie: Optional[str] = None
    prevalence_cameroun: Optional[Decimal] = Field(None, ge=0, le=100)
    niveau_gravite: Optional[int] = Field(None, ge=1, le=5)
    description: Optional[str] = None
    physiopathologie: Optional[str] = None
    evolution_naturelle: Optional[str] = None
    complications: Optional[Dict[str, Any]] = None
    facteurs_risque: Optional[Dict[str, Any]] = None
    prevention: Optional[str] = None


# ==============================================================================
# Schéma pour la Création (ce que l'API attend dans un POST)
# ==============================================================================
class DiseaseCreate(DiseaseBase):
    """
    Schéma utilisé pour créer une nouvelle pathologie.
    """
    pass


# ==============================================================================
# Schéma pour la Mise à Jour (ce que l'API attend dans un PATCH)
# ==============================================================================
class DiseaseUpdate(BaseModel):
    """
    Schéma pour la mise à jour partielle d'une pathologie.
    Tous les champs sont optionnels.
    """
    nom_fr: Optional[str] = None
    code_icd10: Optional[str] = None
    nom_en: Optional[str] = None
    nom_local: Optional[str] = None
    categorie: Optional[str] = None
    prevalence_cameroun: Optional[Decimal] = Field(None, ge=0, le=100)
    niveau_gravite: Optional[int] = Field(None, ge=1, le=5)
    description: Optional[str] = None
    physiopathologie: Optional[str] = None
    evolution_naturelle: Optional[str] = None
    complications: Optional[Dict[str, Any]] = None
    facteurs_risque: Optional[Dict[str, Any]] = None
    prevention: Optional[str] = None


# ==============================================================================
# Schéma pour la Lecture (ce que l'API renvoie)
# ==============================================================================
class Disease(DiseaseBase):
    """
    Schéma complet pour représenter une pathologie en réponse d'API.
    Inclut les champs non modifiables comme 'id' et les horodatages.
    """
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        """
        Permet la conversion automatique depuis un objet SQLAlchemy.
        """
        from_attributes = True

=== Fichier: ./schemas/diagnostic.py ===



=== Fichier: ./schemas/chat_message.py ===

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from datetime import datetime
from uuid import UUID

# ==============================================================================
# Schéma de Base
# ==============================================================================
class ChatMessageBase(BaseModel):
    """
    Schéma de base pour un message de chat.
    Contient les champs communs.
    """
    sender: str = Field(..., description="Qui envoie le message (ex: 'student', 'patient_llm', 'tutor_system')")
    content: str = Field(..., description="Le contenu textuel du message.")


# ==============================================================================
# Schéma pour la Création (ce que le Frontend envoie)
# ==============================================================================
class ChatMessageCreate(ChatMessageBase):
    """
    Schéma utilisé pour créer un nouveau message de chat via l'API.
    La session_id sera fournie dans l'URL, pas dans le corps.
    """
    message_metadata: Optional[Dict[str, Any]] = Field(None, description="Métadonnées optionnelles (ex: intention détectée)")


# ==============================================================================
# Schéma pour la Lecture (ce que l'API renvoie)
# ==============================================================================
class ChatMessage(ChatMessageBase):
    """
    Schéma complet pour représenter un message de chat en réponse d'API.
    """
    id: int
    session_id: UUID
    timestamp: datetime
    message_metadata: Optional[Dict[str, Any]] = None

    class Config:
        """
        Permet la conversion automatique depuis un objet SQLAlchemy.
        """
        from_attributes = True

=== Fichier: ./schemas/base.py ===



=== Fichier: ./schemas/request.py ===



=== Fichier: ./api/v1/chat.py ===

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from uuid import UUID

from ... import schemas, models  # Import global des packages
from ...services import chat_service
from ...dependencies import get_db

router = APIRouter(
    prefix="/chat",
    tags=["Chat"]
)

@router.post("/sessions/{session_id}/messages", response_model=schemas.chat_message.ChatMessage, status_code=status.HTTP_201_CREATED)
def post_chat_message(
    session_id: UUID,
    message_data: schemas.chat_message.ChatMessageCreate,
    db: Session = Depends(get_db)
):
    """Poste un nouveau message dans le chat d'une session de simulation."""
    try:
        return chat_service.create_chat_message(db=db, session_id=session_id, message=message_data)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))

@router.get("/sessions/{session_id}/messages", response_model=List[schemas.chat_message.ChatMessage])
def get_chat_history(session_id: UUID, db: Session = Depends(get_db)):
    """Récupère l'historique complet des messages pour une session."""
    session = db.query(models.SimulationSession).filter(models.SimulationSession.id == session_id).first()
    if not session:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"La session avec l'ID {session_id} n'a pas été trouvée.")
        
    messages = chat_service.get_messages_by_session(db=db, session_id=session_id)
    return messages

=== Fichier: ./api/v1/__init__.py ===



=== Fichier: ./api/v1/simulation.py ===

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from uuid import UUID

# Importe les schémas que nous avons définis
from ... import schemas
from ...dependencies import get_db
# Importe les services
from ...services import tutor_service, simulation_service

router = APIRouter(
    prefix="/simulation",
    tags=["Simulation"]
)

@router.post(
    "/sessions/start",
    response_model=schemas.simulation.SessionStartResponse,
    status_code=status.HTTP_201_CREATED
)
def start_simulation_session(
    request_data: schemas.simulation.SessionStartRequest,
    db: Session = Depends(get_db)
):
    """
    Démarre une nouvelle session de simulation pour un apprenant.
    """
    try:
        session, clinical_case, session_type = tutor_service.start_new_session(
            db=db,
            learner_id=request_data.learner_id,
            category=request_data.category
        )
        return schemas.simulation.SessionStartResponse(
            session_id=session.id,
            session_type=session_type,
            clinical_case=clinical_case
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Une erreur inattendue est survenue: {str(e)}"
        )

@router.post(
    "/sessions/{session_id}/actions",
    response_model=schemas.simulation.LearnerActionResponse
)
def perform_learner_action(
    session_id: UUID,
    action_data: schemas.simulation.LearnerActionRequest,
    db: Session = Depends(get_db)
):
    """
    Traite une action effectuée par l'apprenant pendant une session.
    """
    try:
        action_result, feedback = tutor_service.process_learner_action(
            db=db,
            session_id=session_id,
            action_data=action_data
        )
        return schemas.simulation.LearnerActionResponse(
            action_type=action_data.action_type,
            action_name=action_data.action_name,
            result=action_result,
            feedback=feedback
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erreur lors du traitement de l'action: {str(e)}"
        )

@router.post(
    "/sessions/{session_id}/request-hint",
    response_model=schemas.simulation.HintResponse
)
def request_hint(
    session_id: UUID,
    db: Session = Depends(get_db)
):
    """
    Permet à un apprenant de demander un indice pour la session en cours.
    """
    try:
        hint_type, hint_content = tutor_service.provide_hint(
            db=db,
            session_id=session_id
        )
        
        return schemas.simulation.HintResponse(
            hint_type=hint_type,
            content=hint_content
        )

    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erreur lors de la génération de l'indice: {str(e)}"
        )

# ==============================================================================
# NOUVEL ENDPOINT POUR LA SOUMISSION FINALE
# ==============================================================================

@router.post(
    "/sessions/{session_id}/submit",
    response_model=schemas.simulation.SubmissionResponse
)
def submit_final_diagnosis(
    session_id: UUID,
    submission_data: schemas.simulation.SubmissionRequest,
    db: Session = Depends(get_db)
):
    """
    Soumet le diagnostic et le traitement final de l'apprenant pour évaluation.
    """
    try:
        # La logique complexe d'évaluation est déléguée au service tuteur
        eval_result, feedback, recommendation = tutor_service.evaluate_submission(
            db=db,
            session_id=session_id,
            submission_data=submission_data
        )

        return schemas.simulation.SubmissionResponse(
            evaluation=eval_result,
            feedback_global=feedback,
            recommendation_next_step=recommendation
        )

    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erreur lors de l'évaluation de la soumission: {str(e)}"
        )

=== Fichier: ./api/v1/q_matrix.py ===



=== Fichier: ./api/v1/fultang.py ===



=== Fichier: ./api/v1/media.py ===

from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
    UploadFile,
    File,
    Form
)
from sqlalchemy.orm import Session
from typing import List, Optional

from ... import schemas, models
from ...services import media_service
from ...dependencies import get_db

router = APIRouter(
    prefix="/media",
    tags=["Media"]
)


@router.post("/images/upload", response_model=schemas.media.ImageMedicale, status_code=status.HTTP_201_CREATED)
async def upload_image_medicale(
    file: UploadFile = File(..., description="Le fichier image à uploader"),
    type_examen: str = Form(..., description="Type d'examen (ex: Radiographie)"),
    sous_type: Optional[str] = Form(None, description="Sous-type (ex: Thorax)"),
    pathologie_id: Optional[int] = Form(None, description="ID de la pathologie associée"),
    description: Optional[str] = Form(None, description="Description de l'image"),
    db: Session = Depends(get_db)
):
    """
    Uploade une image médicale et crée l'enregistrement de ses métadonnées.
    """
    # Vérifier le type de fichier si nécessaire
    if not file.content_type.startswith("image/"):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Le fichier uploadé n'est pas une image."
        )

    db_image = await media_service.create_image_medicale(
        db=db,
        file=file,
        type_examen=type_examen,
        sous_type=sous_type,
        pathologie_id=pathologie_id,
        description=description
    )
    return db_image


@router.get("/images", response_model=List[schemas.media.ImageMedicale])
def read_all_images_metadata(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Récupère une liste des métadonnées de toutes les images médicales.
    """
    images = media_service.get_all_images_medicales(db, skip=skip, limit=limit)
    return images


@router.get("/images/{image_id}", response_model=schemas.media.ImageMedicale)
def read_image_metadata(image_id: int, db: Session = Depends(get_db)):
    """
    Récupère les métadonnées d'une image médicale spécifique par son ID.
    """
    db_image = media_service.get_image_medicale_by_id(db, image_id=image_id)
    if db_image is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Image non trouvée.")
    return db_image


@router.patch("/images/{image_id}", response_model=schemas.media.ImageMedicale)
def update_image_metadata(
    image_id: int,
    metadata_update: schemas.media.ImageMedicaleUpdate,
    db: Session = Depends(get_db)
):
    """
    Met à jour les métadonnées d'une image médicale existante.
    """
    db_image = media_service.update_image_medicale_metadata(db, image_id=image_id, image_update=metadata_update)
    if db_image is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Image non trouvée.")
    return db_image


@router.delete("/images/{image_id}", response_model=schemas.media.ImageMedicale)
def delete_image(image_id: int, db: Session = Depends(get_db)):
    """
    Supprime une image médicale (métadonnées et fichier physique).
    """
    db_image = media_service.delete_image_medicale(db, image_id=image_id)
    if db_image is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Image non trouvée.")
    return db_image

=== Fichier: ./api/v1/expert_strategies.py ===

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from ... import schemas, models
from ...services import expert_strategy_service
from ...dependencies import get_db

router = APIRouter(
    prefix="/expert-strategies",
    tags=["Expert Strategies"]
)


@router.post("/", response_model=schemas.expert_strategy.ExpertStrategy, status_code=status.HTTP_201_CREATED)
def create_expert_strategy(strategy_data: schemas.expert_strategy.ExpertStrategyCreate, db: Session = Depends(get_db)):
    """
    Crée une nouvelle règle/stratégie experte.
    """
    db_strategy = expert_strategy_service.get_strategy_by_code(db, code=strategy_data.code_regle)
    if db_strategy:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Une règle avec le code '{strategy_data.code_regle}' existe déjà."
        )
    return expert_strategy_service.create_strategy(db=db, strategy=strategy_data)


@router.get("/", response_model=List[schemas.expert_strategy.ExpertStrategy])
def read_all_expert_strategies(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Récupère une liste de toutes les règles expertes.
    """
    strategies = expert_strategy_service.get_all_strategies(db, skip=skip, limit=limit)
    return strategies


@router.get("/{strategy_id}", response_model=schemas.expert_strategy.ExpertStrategy)
def read_expert_strategy(strategy_id: int, db: Session = Depends(get_db)):
    """
    Récupère une règle experte par son ID.
    """
    db_strategy = expert_strategy_service.get_strategy_by_id(db, strategy_id=strategy_id)
    if db_strategy is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Règle non trouvée.")
    return db_strategy


@router.patch("/{strategy_id}", response_model=schemas.expert_strategy.ExpertStrategy)
def update_expert_strategy(strategy_id: int, strategy_data: schemas.expert_strategy.ExpertStrategyUpdate, db: Session = Depends(get_db)):
    """
    Met à jour une règle experte.
    """
    db_strategy = expert_strategy_service.update_strategy(db, strategy_id=strategy_id, strategy_update=strategy_data)
    if db_strategy is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Règle non trouvée.")
    return db_strategy


@router.delete("/{strategy_id}", response_model=schemas.expert_strategy.ExpertStrategy)
def delete_expert_strategy(strategy_id: int, db: Session = Depends(get_db)):
    """
    Supprime une règle experte.
    """
    db_strategy = expert_strategy_service.delete_strategy(db, strategy_id=strategy_id)
    if db_strategy is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Règle non trouvée.")
    return db_strategy

=== Fichier: ./api/v1/learning_paths.py ===



=== Fichier: ./api/v1/diseases.py ===

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from ... import schemas, models
from ...services import disease_service
from ...dependencies import get_db

router = APIRouter(
    prefix="/diseases",
    tags=["Diseases"]
)


@router.post("/", response_model=schemas.disease.Disease, status_code=status.HTTP_201_CREATED)
def create_disease(disease_data: schemas.disease.DiseaseCreate, db: Session = Depends(get_db)):
    """
    Crée une nouvelle pathologie.
    Vérifie l'unicité du code CIM-10.
    """
    db_disease = disease_service.get_disease_by_icd10(db, icd10_code=disease_data.code_icd10)
    if db_disease:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Une pathologie avec le code CIM-10 '{disease_data.code_icd10}' existe déjà."
        )
    return disease_service.create_disease(db=db, disease=disease_data)


@router.get("/", response_model=List[schemas.disease.Disease])
def read_diseases(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Récupère une liste de pathologies.
    """
    diseases = disease_service.get_all_diseases(db, skip=skip, limit=limit)
    return diseases


@router.get("/{disease_id}", response_model=schemas.disease.Disease)
def read_disease(disease_id: int, db: Session = Depends(get_db)):
    """
    Récupère une pathologie par son ID.
    """
    db_disease = disease_service.get_disease_by_id(db, disease_id=disease_id)
    if db_disease is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Pathologie non trouvée.")
    return db_disease


@router.patch("/{disease_id}", response_model=schemas.disease.Disease)
def update_disease(disease_id: int, disease_data: schemas.disease.DiseaseUpdate, db: Session = Depends(get_db)):
    """
    Met à jour une pathologie.
    """
    db_disease = disease_service.update_disease(db, disease_id=disease_id, disease_update=disease_data)
    if db_disease is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Pathologie non trouvée.")
    return db_disease


@router.delete("/{disease_id}", response_model=schemas.disease.Disease)
def delete_disease(disease_id: int, db: Session = Depends(get_db)):
    """
    Supprime une pathologie.
    """
    db_disease = disease_service.delete_disease(db, disease_id=disease_id)
    if db_disease is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Pathologie non trouvée.")
    return db_disease

# Contenu à AJOUTER à la fin de app/api/v1/diseases.py

@router.post(
    "/{disease_id}/symptoms",
    response_model=schemas.relations.PathologieSymptome,
    status_code=status.HTTP_201_CREATED,
    tags=["Disease-Symptom Relations"] # Un nouveau tag pour l'organisation
)
def add_symptom_to_disease(
    disease_id: int, 
    association_data: schemas.relations.PathologieSymptomeCreate, 
    db: Session = Depends(get_db)
):
    """
    Associe un symptôme à une pathologie avec des attributs de relation
    (probabilité, importance, etc.).
    """
    # Assurer la cohérence des IDs
    if disease_id != association_data.pathologie_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="L'ID de la pathologie dans l'URL ne correspond pas à celui dans le corps de la requête."
        )
    
    try:
        return disease_service.add_symptom_to_disease(db=db, association_data=association_data)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))


@router.get(
    "/{disease_id}/symptoms",
    response_model=List[schemas.relations.SymptomForDiseaseDetail],
    tags=["Disease-Symptom Relations"]
)
def get_symptoms_for_disease(disease_id: int, db: Session = Depends(get_db)):
    """
    Récupère la liste de tous les symptômes associés à une pathologie,
    avec les détails de la relation et les détails du symptôme lui-même.
    """
    associations = disease_service.get_symptoms_for_disease(db, disease_id=disease_id)
    if not associations:
        # Ce n'est pas une erreur, la maladie peut simplement n'avoir aucun symptôme associé pour l'instant
        return []
    
    # Transformer les données pour correspondre au schéma de réponse attendu
    response = []
    for assoc in associations:
        response.append({
            "symptome": assoc.symptome, # L'objet Symptom complet
            "probabilite": assoc.probabilite,
            "importance_diagnostique": assoc.importance_diagnostique,
            "est_pathognomonique": assoc.est_pathognomonique
        })
    return response


# Contenu à AJOUTER à la fin de app/api/v1/diseases.py

@router.post(
    "/{disease_id}/treatments",
    response_model=schemas.relations.TraitementPathologie,
    status_code=status.HTTP_201_CREATED,
    tags=["Therapeutic Relations"]
)
def add_treatment_to_disease(
    disease_id: int, 
    association_data: schemas.relations.TraitementPathologieCreate, 
    db: Session = Depends(get_db)
):
    """
    Associe un médicament à une pathologie en tant que traitement.
    """
    if disease_id != association_data.pathologie_id:
        raise HTTPException(status_code=400, detail="Incohérence des IDs de pathologie.")
    
    try:
        return disease_service.add_treatment_to_disease(db=db, association_data=association_data)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.get(
    "/{disease_id}/treatments",
    response_model=List[schemas.relations.MedicationForDiseaseDetail],
    tags=["Therapeutic Relations"]
)
def get_treatments_for_disease(disease_id: int, db: Session = Depends(get_db)):
    """
    Récupère la liste des traitements recommandés pour une pathologie.
    """
    associations = disease_service.get_treatments_for_disease(db, disease_id=disease_id)
    return [
        {
            "medicament": assoc.medicament,
            "type_traitement": assoc.type_traitement,
            "ligne_traitement": assoc.ligne_traitement,
            "rang_preference": assoc.rang_preference,
        }
        for assoc in associations
    ]

=== Fichier: ./api/v1/diagnostic.py ===

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Dict, Any

from ...services import diagnostic_engine
from ...dependencies import get_db

router = APIRouter(
    prefix="/diagnostic-engine",
    tags=["Diagnostic Engine"]
)


@router.post("/run", response_model=List[Dict[str, Any]])
def run_diagnostic_engine(
    patient_facts: diagnostic_engine.DiagnosticInput,
    db: Session = Depends(get_db)
):
    """
    Exécute le moteur de raisonnement sur un ensemble de faits patient.

    Prend en entrée une liste de symptômes et de contextes, et retourne
    une liste d'actions/conclusions basées sur les règles expertes actives
    dans le système.
    """
    if not patient_facts.symptoms:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="La liste des symptômes ne peut pas être vide."
        )

    conclusions = diagnostic_engine.run_diagnostic(db=db, patient_facts=patient_facts)
    
    return conclusions

=== Fichier: ./api/v1/clinical_cases.py ===

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from ... import schemas, models
from ...services import clinical_case_service, media_service, symptom_service, disease_service
from ...dependencies import get_db

router = APIRouter(
    prefix="/clinical-cases",
    tags=["Clinical Cases"]
)


@router.post("/", response_model=schemas.clinical_case.ClinicalCase, status_code=status.HTTP_201_CREATED)
def create_clinical_case(case_data: schemas.clinical_case.ClinicalCaseCreate, db: Session = Depends(get_db)):
    """
    Crée un nouveau cas clinique.
    """
    db_case_by_code = clinical_case_service.get_case_by_code(db, code=case_data.code_fultang)
    if db_case_by_code:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Un cas avec le code '{case_data.code_fultang}' existe déjà."
        )
    try:
        # Le service create_case retournera un objet SQLAlchemy
        db_case = clinical_case_service.create_case(db=db, case=case_data)
        # La conversion vers le schéma Pydantic se fait automatiquement par FastAPI
        return db_case
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/", response_model=List[schemas.clinical_case.ClinicalCaseSimple])
def read_all_clinical_cases(skip: int = 0, limit: int = 25, db: Session = Depends(get_db)):
    """
    Récupère une liste simplifiée de cas cliniques.
    """
    cases = clinical_case_service.get_all_cases(db, skip=skip, limit=limit)
    
    # La conversion vers le schéma Pydantic gère automatiquement la construction de la réponse
    # en utilisant les relations SQLAlchemy et les configurations 'from_attributes'.
    # Cependant, pour des champs calculés comme 'nb_images', nous devons construire la réponse manuellement.
    response = []
    for case in cases:
        case_simple = schemas.clinical_case.ClinicalCaseSimple(
            id=case.id,
            code_fultang=case.code_fultang,
            niveau_difficulte=case.niveau_difficulte,
            pathologie_principale=case.pathologie_principale,
            nb_images=len(case.images_associees_ids) if case.images_associees_ids else 0,
            nb_sons=len(case.sons_associes_ids) if case.sons_associes_ids else 0,
        )
        response.append(case_simple)
    return response


@router.get("/{case_id}", response_model=schemas.clinical_case.ClinicalCase)
def read_clinical_case(case_id: int, db: Session = Depends(get_db)):
    """
    Récupère un cas clinique complet par son ID, avec tous les objets liés.
    """
    # 1. Récupérer le cas brut
    db_case = clinical_case_service.get_case_by_id(db, case_id=case_id)
    if db_case is None:
        raise HTTPException(status_code=404, detail="Cas clinique non trouvé.")
    
    # 2. Convertir en dictionnaire pour pouvoir injecter les champs enrichis
    case_dict = db_case.__dict__

    # 3. Enrichir : Pathologies Secondaires
    pathologies_secondaires = []
    if db_case.pathologies_secondaires_ids:
        for p_id in db_case.pathologies_secondaires_ids:
            p_obj = disease_service.get_disease_by_id(db, disease_id=p_id)
            if p_obj:
                pathologies_secondaires.append(p_obj)
    case_dict['pathologies_secondaires'] = pathologies_secondaires

    # 4. Enrichir : Images
    images = []
    if db_case.images_associees_ids:
        for img_id in db_case.images_associees_ids:
            img = media_service.get_image_medicale_by_id(db, image_id=img_id)
            if img:
                images.append(img)
    case_dict['images_associees'] = images

    # 5. Enrichir : Présentation Clinique Détaillée
    # Le champ 'presentation_clinique' en base contient juste des IDs.
    # Nous devons aller chercher les objets Symptômes complets.
    symptomes_details_in_case = []
    presentation_dict = db_case.presentation_clinique or {}
    
    if 'symptomes_patient' in presentation_dict:
        for item in presentation_dict['symptomes_patient']:
            # item ressemble à {'symptome_id': 1, 'details': 'Fièvre forte'}
            sympt_id = item.get('symptome_id')
            sympt_obj = symptom_service.get_symptom_by_id(db, symptom_id=sympt_id)
            
            if sympt_obj:
                symptomes_details_in_case.append({
                    "symptome": sympt_obj, # L'objet complet
                    "details": item.get('details', '')
                })
    
    case_dict['presentation_clinique_detail'] = {
        "histoire_maladie": presentation_dict.get('histoire_maladie', ''),
        "symptomes_patient": symptomes_details_in_case,
        "antecedents": presentation_dict.get('antecedents')
    }

    # 6. Validation et Retour
    # On passe le dictionnaire enrichi à Pydantic pour qu'il le valide et le formate
    return schemas.clinical_case.ClinicalCase.model_validate(case_dict)

@router.patch("/{case_id}", response_model=schemas.clinical_case.ClinicalCase)
def update_clinical_case(case_id: int, case_data: schemas.clinical_case.ClinicalCaseUpdate, db: Session = Depends(get_db)):
    """
    Met à jour un cas clinique.
    """
    db_case = clinical_case_service.update_case(db, case_id=case_id, case_update=case_data)
    if db_case is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Cas clinique non trouvé.")
    # La conversion vers le schéma de réponse se fait automatiquement
    return db_case


@router.delete("/{case_id}", response_model=schemas.clinical_case.ClinicalCase)
def delete_clinical_case(case_id: int, db: Session = Depends(get_db)):
    """
    Supprime un cas clinique.
    """
    db_case = clinical_case_service.delete_case(db, case_id=case_id)
    if db_case is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Cas clinique non trouvé.")
    # La conversion vers le schéma de réponse se fait automatiquement
    return db_case



@router.get("/{case_id}/simple", response_model=schemas.clinical_case.ClinicalCaseSimple)
def read_clinical_case_simple(case_id: int, db: Session = Depends(get_db)):
    """
    Récupère un cas clinique dans une structure simplifiée avec la pathologie principale complète.
    Retourne exactement la même structure que ClinicalCaseSimple mais avec l'objet pathologie_principale complet.
    """
    # Récupérer le cas
    db_case = clinical_case_service.get_case_by_id(db, case_id=case_id)
    if db_case is None:
        raise HTTPException(status_code=404, detail="Cas clinique non trouvé.")
    
    # Construire la réponse simple
    case_simple = schemas.clinical_case.ClinicalCaseSimple(
        id=db_case.id,
        code_fultang=db_case.code_fultang,
        niveau_difficulte=db_case.niveau_difficulte,
        pathologie_principale=db_case.pathologie_principale,  # L'objet complet sera sérialisé
        nb_images=len(db_case.images_associees_ids) if db_case.images_associees_ids else 0,
        nb_sons=len(db_case.sons_associes_ids) if db_case.sons_associes_ids else 0,
    )
    
    return case_simple

=== Fichier: ./api/v1/knowledge_graph.py ===



=== Fichier: ./api/v1/medications.py ===

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from ... import schemas, models
from ...services import medication_service
from ...dependencies import get_db

router = APIRouter(
    prefix="/medications",
    tags=["Medications"]
)


@router.post("/", response_model=schemas.medication.Medication, status_code=status.HTTP_201_CREATED)
def create_medication(medication_data: schemas.medication.MedicationCreate, db: Session = Depends(get_db)):
    """
    Crée un nouveau médicament.
    Vérifie l'unicité du DCI (Dénomination Commune Internationale).
    """
    db_medication = medication_service.get_medication_by_dci(db, dci=medication_data.dci)
    if db_medication:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Un médicament avec le DCI '{medication_data.dci}' existe déjà."
        )
    return medication_service.create_medication(db=db, medication=medication_data)


@router.get("/", response_model=List[schemas.medication.Medication])
def read_medications(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Récupère une liste de médicaments.
    """
    medications = medication_service.get_all_medications(db, skip=skip, limit=limit)
    return medications


@router.get("/{medication_id}", response_model=schemas.medication.Medication)
def read_medication(medication_id: int, db: Session = Depends(get_db)):
    """
    Récupère un médicament par son ID.
    """
    db_medication = medication_service.get_medication_by_id(db, medication_id=medication_id)
    if db_medication is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Médicament non trouvé.")
    return db_medication


@router.patch("/{medication_id}", response_model=schemas.medication.Medication)
def update_medication(medication_id: int, medication_data: schemas.medication.MedicationUpdate, db: Session = Depends(get_db)):
    """
    Met à jour un médicament.
    """
    db_medication = medication_service.update_medication(db, medication_id=medication_id, medication_update=medication_data)
    if db_medication is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Médicament non trouvé.")
    return db_medication


@router.delete("/{medication_id}", response_model=schemas.medication.Medication)
def delete_medication(medication_id: int, db: Session = Depends(get_db)):
    """
    Supprime un médicament.
    """
    db_medication = medication_service.delete_medication(db, medication_id=medication_id)
    if db_medication is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Médicament non trouvé.")
    return db_medication

=== Fichier: ./api/v1/symptoms.py ===

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from ... import schemas, models
from ...services import symptom_service
from ...dependencies import get_db

# Création d'un nouveau routeur.
# C'est comme une mini-application FastAPI que l'on pourra inclure dans notre app principale.
router = APIRouter(
    prefix="/symptoms",  # Toutes les routes de ce fichier commenceront par /symptoms
    tags=["Symptoms"]      # Groupe les routes dans la documentation interactive
)


@router.post("/", response_model=schemas.Symptom, status_code=status.HTTP_201_CREATED)
def create_symptom(symptom: schemas.SymptomCreate, db: Session = Depends(get_db)):
    """
    Crée un nouveau symptôme.
    """
    # Vérifie si un symptôme avec le même nom existe déjà
    db_symptom = symptom_service.get_symptom_by_name(db, name=symptom.nom)
    if db_symptom:
        raise HTTPException(status_code=400, detail="Un symptôme avec ce nom existe déjà.")
    
    return symptom_service.create_symptom(db=db, symptom=symptom)


@router.get("/", response_model=List[schemas.Symptom])
def read_symptoms(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Récupère une liste de symptômes.
    """
    symptoms = symptom_service.get_all_symptoms(db, skip=skip, limit=limit)
    return symptoms


@router.get("/{symptom_id}", response_model=schemas.Symptom)
def read_symptom(symptom_id: int, db: Session = Depends(get_db)):
    """
    Récupère un symptôme par son ID.
    """
    db_symptom = symptom_service.get_symptom_by_id(db, symptom_id=symptom_id)
    if db_symptom is None:
        raise HTTPException(status_code=404, detail="Symptôme non trouvé.")
    return db_symptom


@router.patch("/{symptom_id}", response_model=schemas.Symptom)
def update_symptom(symptom_id: int, symptom: schemas.SymptomUpdate, db: Session = Depends(get_db)):
    """
    Met à jour un symptôme.
    """
    db_symptom = symptom_service.update_symptom(db, symptom_id=symptom_id, symptom_update=symptom)
    if db_symptom is None:
        raise HTTPException(status_code=404, detail="Symptôme non trouvé.")
    return db_symptom


@router.delete("/{symptom_id}", response_model=schemas.Symptom)
def delete_symptom(symptom_id: int, db: Session = Depends(get_db)):
    """
    Supprime un symptôme.
    """
    db_symptom = symptom_service.delete_symptom(db, symptom_id=symptom_id)
    if db_symptom is None:
        raise HTTPException(status_code=404, detail="Symptôme non trouvé.")
    return db_symptom

# Contenu à AJOUTER à la fin de app/api/v1/symptoms.py

@router.get(
    "/{symptom_id}/diseases",
    response_model=List[schemas.relations.DiseaseForSymptomDetail],
    tags=["Disease-Symptom Relations"]
)
def get_diseases_for_symptom(symptom_id: int, db: Session = Depends(get_db)):
    """
    Récupère la liste de toutes les pathologies pouvant présenter ce symptôme
    (utile pour le diagnostic différentiel).
    """
    associations = symptom_service.get_diseases_for_symptom(db, symptom_id=symptom_id)
    if not associations:
        return []
        
    response = []
    for assoc in associations:
        response.append({
            "pathologie": assoc.pathologie,
            "probabilite": assoc.probabilite,
            "importance_diagnostique": assoc.importance_diagnostique
        })
    return response



# Contenu à AJOUTER à la fin de app/api/v1/symptoms.py

@router.post(
    "/{symptom_id}/treatments",
    response_model=schemas.relations.TraitementSymptome,
    status_code=status.HTTP_201_CREATED,
    tags=["Therapeutic Relations"]
)
def add_treatment_to_symptom(
    symptom_id: int,
    association_data: schemas.relations.TraitementSymptomeCreate,
    db: Session = Depends(get_db)
):
    """
    Associe un médicament à un symptôme pour un traitement symptomatique.
    """
    if symptom_id != association_data.symptome_id:
        raise HTTPException(status_code=400, detail="Incohérence des IDs de symptôme.")
    
    try:
        return symptom_service.add_treatment_to_symptom(db=db, association_data=association_data)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.get(
    "/{symptom_id}/treatments",
    response_model=List[schemas.relations.MedicationForSymptomDetail],
    tags=["Therapeutic Relations"]
)
def get_treatments_for_symptom(symptom_id: int, db: Session = Depends(get_db)):
    """
    Récupère la liste des traitements pour un symptôme spécifique.
    """
    associations = symptom_service.get_treatments_for_symptom(db, symptom_id=symptom_id)
    return [
        {
            "medicament": assoc.medicament,
            "efficacite": assoc.efficacite,
            "rang_preference": assoc.rang_preference,
        }
        for assoc in associations
    ]

=== Fichier: ./api/__init__.py ===



=== Fichier: ./database.py ===

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from .config import settings

# L'objet 'engine' est le point d'entrée principal pour communiquer avec la BDD.
engine = create_engine(
    settings.DATABASE_URL,
    # pool_pre_ping=True # Option utile en production
)

# La 'SessionLocal' est une "usine" à sessions de base de données.
# Chaque fois que nous aurons besoin de parler à la BDD, nous demanderons une session à cette usine.
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

=== Fichier: ./models/tutor_models.py ===

from sqlalchemy import Column, Integer, String, Text, Float, ForeignKey, JSON, TIMESTAMP, text, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
from .base import Base

class LearningPath(Base):
    __tablename__ = "learning_paths"

    id = Column(Integer, primary_key=True, index=True)
    learner_id = Column(Integer, ForeignKey("learners.id"), nullable=False)
    
    algorithme_recommandation = Column(String(100))
    ordered_case_ids = Column(JSON, comment="Liste ordonnée des IDs des cas") 
    progression = Column(Float, default=0.0)
    status = Column(String(50), default="in_progress")
    created_at = Column(TIMESTAMP, server_default=text("now()"))

    learner = relationship("Learner")


class TutorDecision(Base):
    __tablename__ = "tutor_decisions"

    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    trigger_event_id = Column(Integer, ForeignKey("interaction_logs.id"), nullable=True)
    
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    strategy_used = Column(String(100)) # Socratique, Scaffolding...
    action_choisie = Column(String(100)) # Hint, Encouragement
    intervention_content = Column(Text)
    rationale = Column(JSON) # Pourquoi j'ai fait ça ?
    succes_intervention = Column(Boolean, nullable=True)

    session = relationship("SimulationSession", back_populates="tutor_decisions")


class TutorStrategiesHistory(Base):
    __tablename__ = "tutor_strategies_history"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    strategy_name = Column(String(100))
    relevance_score = Column(Float)


class TutorScaffoldingState(Base):
    __tablename__ = "tutor_scaffolding_state"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    competence_cible_id = Column(Integer, ForeignKey("competences_cliniques.id"))
    current_level = Column(Integer, default=0)
    indices_deja_donnes = Column(JSON)


class TutorSocraticState(Base):
    __tablename__ = "tutor_socratic_state"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    tactic_used = Column(String(100))
    target_concept = Column(String(255))
    step_in_dialogue = Column(Integer)


class TutorMotivationalState(Base):
    __tablename__ = "tutor_motivational_state"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    intervention_type = Column(String(100))
    emotional_state_before = Column(JSON)


class TutorFeedbackLog(Base):
    __tablename__ = "tutor_feedback_logs"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    feedback_type = Column(String(50))
    content = Column(Text)

=== Fichier: ./models/symptom.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    Boolean,
    JSON,
    TIMESTAMP,
    text
)
from pgvector.sqlalchemy import Vector
from sqlalchemy.orm import relationship

from .base import Base


class Symptom(Base):
    """
    Modèle SQLAlchemy pour la table des symptômes.

    Cette table est le catalogue central de tous les symptômes connus par le système expert.
    Elle inclut des informations détaillées pour permettre un raisonnement clinique fin
    et des recherches sémantiques.
    """
    __tablename__ = "symptomes"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification et Catégorisation ---
    nom = Column(String(255), nullable=False, unique=True, index=True)
    nom_local = Column(String(255), comment="Nom vernaculaire ou local, ex: 'Ntou-tou' pour la toux")
    categorie = Column(String(100), index=True, comment="Catégorie fonctionnelle (ex: Respiratoire, Neurologique, Digestif)")
    type_symptome = Column(String(50), comment="Type de symptôme (ex: Subjectif, Objectif, Signe clinique)")

    # --- Description et Contexte Clinique ---
    description = Column(Text, comment="Description détaillée du symptôme et de sa signification clinique.")
    questions_anamnese = Column(JSON, comment="Liste structurée de questions pour explorer ce symptôme (ex: PQRST)")
    signes_alarme = Column(Boolean, default=False, nullable=False, comment="Indique si ce symptôme est un signe de gravité ('red flag')")

    # --- Intelligence Artificielle ---
    embedding_vector = Column(Vector(384), nullable=True, comment="Vecteur d'embedding pour la recherche sémantique (ex: BioBERT)")

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    # --- Relations ---
    # Relation vers la table d'association 'pathologie_symptomes'
    # 'back_populates' assure la synchronisation de la relation des deux côtés.
    # 'cascade' signifie que si un symptôme est supprimé, ses associations le seront aussi.
    pathologies = relationship(
        "PathologieSymptome",
        back_populates="symptome",
        cascade="all, delete-orphan"
    )
    traitements = relationship(
        "TraitementSymptome",
        back_populates="symptome",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Symptom(id={self.id}, nom='{self.nom}')>"

=== Fichier: ./models/medication.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    text
)
from pgvector.sqlalchemy import Vector
from sqlalchemy.orm import relationship
from .base import Base


class Medication(Base):
    """
    Modèle SQLAlchemy pour la table des médicaments.

    Cette table est le catalogue central de tous les médicaments connus par le système,
    incluant des informations pharmacologiques et contextuelles (disponibilité, coût).
    """
    __tablename__ = "medicaments"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification ---
    nom_commercial = Column(String(255), index=True)
    dci = Column(String(255), nullable=False, index=True, comment="Dénomination Commune Internationale")
    
    # --- Classification et Formulation ---
    classe_therapeutique = Column(String(255), index=True)
    forme_galenique = Column(String(100), comment="Ex: Comprimé, Sirop, Injectable")
    dosage = Column(String(100))
    voie_administration = Column(String(100), comment="Ex: Orale, IV, IM, Cutanée")

    # --- Informations Pharmacologiques ---
    mecanisme_action = Column(Text)
    indications = Column(JSON)
    contre_indications = Column(JSON)
    effets_secondaires = Column(JSON)
    interactions_medicamenteuses = Column(JSON)
    precautions_emploi = Column(Text)
    posologie_standard = Column(JSON, comment="Posologie standard par âge, poids, indication")

    # --- Contexte Local (Cameroun) ---
    disponibilite_cameroun = Column(String(50), comment="Ex: Urbain, Rural, CHU_uniquement")
    cout_moyen_fcfa = Column(Integer)
    statut_prescription = Column(String(50), comment="Ex: Prescription_obligatoire, OTC")

    # --- Intelligence Artificielle ---
    embedding_vector = Column(Vector(384), nullable=True, comment="Vecteur d'embedding pour la recherche de médicaments similaires")

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    traitements_pathologies = relationship("TraitementPathologie", back_populates="medicament")
    traitements_symptomes = relationship("TraitementSymptome", back_populates="medicament")

    def __repr__(self) -> str:
        return f"<Medication(id={self.id}, dci='{self.dci}')>"

=== Fichier: ./models/clinical_case.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    Boolean,
    Date,
    ForeignKey,
    ARRAY,
    DECIMAL,
    text
)
from sqlalchemy.orm import relationship
from pgvector.sqlalchemy import Vector

from .base import Base


class ClinicalCase(Base):
    """
    Modèle SQLAlchemy pour la table des cas cliniques enrichis.
    C'est l'objet central utilisé pour les scénarios d'apprentissage.
    """
    __tablename__ = "cas_cliniques_enrichis"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification et Intégrité ---
    code_fultang = Column(String(100), unique=True, index=True, comment="Identifiant unique provenant de Fultang (ou synthétique)")
    hash_integrite = Column(String(64), nullable=True, comment="SHA-256 pour la preuve d'intégrité des données brutes")

    # --- Liaisons aux Connaissances de Base ---
    pathologie_principale_id = Column(Integer, ForeignKey("pathologies.id"), nullable=True, index=True)
    pathologies_secondaires_ids = Column(ARRAY(Integer), comment="Liste d'IDs de pathologies comorbides ou secondaires")

    # --- Données du Scénario ---
    donnees_brutes = Column(JSON, nullable=True, comment="Données originales (ex: de Fultang) avant traitement")
    presentation_clinique = Column(JSON, nullable=False, comment="Histoire du patient, symptômes présentés, etc.")
    donnees_paracliniques = Column(JSON, comment="Résultats des examens pour ce cas spécifique")
    evolution_patient = Column(Text, comment="Description de l'évolution du patient pendant le cas")
    
    # --- Liaisons Multimédia ---
    images_associees_ids = Column(ARRAY(Integer), comment="Liste des IDs des images de la table 'images_medicales'")
    sons_associes_ids = Column(ARRAY(Integer), comment="Liste des IDs des sons de la table 'sons_medicaux'")

    # --- Liaisons Thérapeutiques ---
    medicaments_prescrits = Column(JSON, comment="Liste des médicaments prescrits dans ce cas")

    # --- Métadonnées Pédagogiques ---
    niveau_difficulte = Column(Integer, default=3, comment="Difficulté du cas (1-5)")
    duree_estimee_resolution_min = Column(Integer, comment="Temps estimé pour résoudre le cas")
    objectifs_apprentissage = Column(JSON, comment="Liste des compétences à acquérir")
    competences_requises = Column(JSON, comment="Mapping Q-Matrix pour ce cas")

    valide_expert = Column(Boolean, default=False)
    
    # Clé étrangère vers la table experts
    expert_validateur_id = Column(Integer, ForeignKey("experts.id"), nullable=True)
    
    # Relation avec ExpertUser
    expert_validateur = relationship("ExpertUser", back_populates="cas_valides")
    date_validation = Column(Date)

    qualite_donnees = Column(Integer, comment="Qualité des données sources (1-5)")

    # --- Métriques d'Utilisation ---
    nb_utilisations = Column(Integer, default=0)
    note_moyenne_apprenants = Column(DECIMAL(3, 2))
    taux_succes_diagnostic = Column(DECIMAL(5, 2))
    
    # --- Intelligence Artificielle ---
    embedding_texte = Column(Vector(384), nullable=True, comment="Embedding de la description textuelle du cas")
    embedding_global = Column(Vector(1536), nullable=True, comment="Embedding multimodal fusionné (texte+image+son)")
    
    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    # --- Relations ---
    pathologie_principale = relationship("Disease")

    def __repr__(self) -> str:
        return f"<ClinicalCase(id={self.id}, code='{self.code_fultang}')>"

=== Fichier: ./models/learner_models.py ===

from sqlalchemy import Column, Integer, String, Float, ForeignKey, JSON, TIMESTAMP, text, Boolean
from sqlalchemy.orm import relationship
from .base import Base

class Learner(Base):
    __tablename__ = "learners"

    id = Column(Integer, primary_key=True, index=True)
    matricule = Column(String(50), unique=True, index=True)
    nom = Column(String(255))
    email = Column(String(255), unique=True, index=True)
    niveau_etudes = Column(String(50)) # Med 3, Interne...
    specialite_visee = Column(String(100))
    langue_preferee = Column(String(10), default="fr")
    date_inscription = Column(TIMESTAMP, server_default=text("now()"))

    # Relations
    competency_mastery = relationship("LearnerCompetencyMastery", back_populates="learner")
    misconceptions = relationship("LearnerMisconception", back_populates="learner")
    sessions = relationship("SimulationSession", back_populates="learner")


class LearnerCompetencyMastery(Base):
    __tablename__ = "learner_competency_mastery"

    id = Column(Integer, primary_key=True, index=True)
    learner_id = Column(Integer, ForeignKey("learners.id"), nullable=False)
    competence_id = Column(Integer, ForeignKey("competences_cliniques.id"), nullable=False)
    
    mastery_level = Column(Float, default=0.0) # Probabilité BKT (0-1)
    confidence = Column(Float, default=0.0) # Certitude du système
    last_practice_date = Column(TIMESTAMP)
    nb_success = Column(Integer, default=0)
    nb_failures = Column(Integer, default=0)
    streak_correct = Column(Integer, default=0)

    learner = relationship("Learner", back_populates="competency_mastery")
    competence = relationship("Competence") # Lien vers Module Expert


class LearnerCognitiveProfile(Base):
    __tablename__ = "learner_cognitive_profiles"

    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"), unique=True)
    
    vitesse_assimilation = Column(Float)
    capacite_memoire_travail = Column(Float)
    tendance_impulsivite = Column(Float) # 0 (Réfléchi) - 1 (Impulsif)
    prefer_visual = Column(Boolean, default=False)
    
    learner = relationship("Learner")


class LearnerMisconception(Base):
    __tablename__ = "learner_misconceptions"

    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    
    type_erreur = Column(String(255)) # ex: "Confond Virus/Bactérie"
    frequence_apparition = Column(Integer, default=1)
    resistance_correction = Column(Float, default=0.0) # 0-1
    detected_at = Column(TIMESTAMP, server_default=text("now()"))
    
    learner = relationship("Learner", back_populates="misconceptions")


class LearnerGoal(Base):
    __tablename__ = "learner_goals"
    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    type_objectif = Column(String(100))
    domaine_cible = Column(String(100))
    date_limite = Column(TIMESTAMP)
    statut = Column(String(50)) # en_cours, atteint, abandonne


class LearnerPreference(Base):
    __tablename__ = "learner_preferences"
    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    cle = Column(String(100))
    valeur = Column(String(255))


class LearnerAchievement(Base):
    __tablename__ = "learner_achievements"
    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    badge_id = Column(String(100))
    date_obtention = Column(TIMESTAMP, server_default=text("now()"))


class LearnerStrategy(Base):
    __tablename__ = "learner_strategies"
    id = Column(Integer, primary_key=True)
    learner_id = Column(Integer, ForeignKey("learners.id"))
    strategy_name = Column(String(100)) # ex: "Gaming", "Help Seeking"
    frequency = Column(Integer)
    effectiveness = Column(Float)

=== Fichier: ./models/relations.py ===

from sqlalchemy import (
    JSON,
    Column,
    Integer,
    ForeignKey,
    DECIMAL,
    String,
    Boolean,
    Text
)
from sqlalchemy.orm import relationship

from .base import Base


class PathologieSymptome(Base):
    """
    Modèle de la table d'association entre Pathologies et Symptômes.

    Cette table matérialise la relation "plusieurs-à-plusieurs" et permet de stocker
    des informations contextuelles sur le lien, telles que la probabilité
    d'apparition, la spécificité, etc.
    """
    __tablename__ = "pathologie_symptomes"

    id = Column(Integer, primary_key=True)

    # --- Clés Étrangères ---
    pathologie_id = Column(Integer, ForeignKey("pathologies.id"), nullable=False)
    symptome_id = Column(Integer, ForeignKey("symptomes.id"), nullable=False)

    # --- Attributs de la Relation ---
    probabilite = Column(DECIMAL(5, 4), comment="Probabilité d'apparition du symptôme pour cette pathologie P(symptôme|pathologie)")
    sensibilite = Column(DECIMAL(5, 4))
    specificite = Column(DECIMAL(5, 4))
    phase_maladie = Column(String(50), comment="Phase de la maladie où le symptôme apparaît (ex: Précoce, Tardive)")
    frequence = Column(String(50), comment="Fréquence d'apparition (ex: Constant, Fréquent, Occasionnel)")
    est_pathognomonique = Column(Boolean, default=False, comment="Si True, ce symptôme seul suffit presque à poser le diagnostic")
    importance_diagnostique = Column(Integer, comment="Échelle de 1 à 5 sur l'importance de ce symptôme pour le diagnostic")

    # --- Relations Inverses (Back-population) ---
    # Permet d'accéder à l'objet parent directement depuis une instance de cette classe.
    # ex: mon_association.pathologie -> renvoie l'objet Disease
    pathologie = relationship("Disease", back_populates="symptomes")
    symptome = relationship("Symptom", back_populates="pathologies")

    def __repr__(self) -> str:
        return f"<PathologieSymptome(pathologie_id={self.pathologie_id}, symptome_id={self.symptome_id})>"
    

# Contenu à AJOUTER à la fin de app/models/relations.py

class TraitementPathologie(Base):
    """
    Table d'association pour les traitements spécifiques aux pathologies.
    """
    __tablename__ = "traitements_pathologies"

    id = Column(Integer, primary_key=True)
    pathologie_id = Column(Integer, ForeignKey("pathologies.id"), nullable=False)
    medicament_id = Column(Integer, ForeignKey("medicaments.id"), nullable=False)

    type_traitement = Column(String(50), comment="Ex: Premiere_intention, Alternative, Adjuvant")
    ligne_traitement = Column(Integer, comment="Ex: 1ère ligne, 2e ligne")
    indication_precise = Column(Text)
    efficacite_taux = Column(DECIMAL(5, 2), comment="Taux de succès en %")
    duree_traitement_jours = Column(Integer)
    posologie_detaillee = Column(JSON)
    niveau_preuve = Column(String(50), comment="Grade de recommandation (A, B, C)")
    guidelines_source = Column(String(255), comment="Source (OMS, MINSANTE Cameroun, etc.)")
    rang_preference = Column(Integer, default=99)

    pathologie = relationship("Disease", back_populates="traitements")
    medicament = relationship("Medication", back_populates="traitements_pathologies")


class TraitementSymptome(Base):
    """
    Table d'association pour les traitements symptomatiques.
    """
    __tablename__ = "traitements_symptomes"

    id = Column(Integer, primary_key=True)
    symptome_id = Column(Integer, ForeignKey("symptomes.id"), nullable=False)
    medicament_id = Column(Integer, ForeignKey("medicaments.id"), nullable=False)

    efficacite = Column(String(50), comment="Ex: Tres_efficace, Efficace, Modere")
    rapidite_action = Column(String(100), comment="Ex: Immediate, <30min")
    posologie_recommandee = Column(Text)
    rang_preference = Column(Integer, default=99)
    
    symptome = relationship("Symptom", back_populates="traitements")
    medicament = relationship("Medication", back_populates="traitements_symptomes")




=== Fichier: ./models/tracking_models.py ===

from sqlalchemy import Column, Integer, String, Float, ForeignKey, JSON, TIMESTAMP, text, Boolean, Text
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
import uuid
from .base import Base

class SimulationSession(Base):
    __tablename__ = "simulation_sessions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    learner_id = Column(Integer, ForeignKey("learners.id"), nullable=False)
    cas_clinique_id = Column(Integer, ForeignKey("cas_cliniques_enrichis.id"), nullable=False)
    
    start_time = Column(TIMESTAMP, server_default=text("now()"))
    end_time = Column(TIMESTAMP)
    score_final = Column(Float)
    temps_total = Column(Integer)
    cout_virtuel_genere = Column(Integer)
    statut = Column(String(50), default="en_cours")
    raison_fin = Column(String(100))
    current_stage = Column(String(50))
    context_state = Column(JSON)

    learner = relationship("Learner", back_populates="sessions")
    cas_clinique = relationship("ClinicalCase")
    
    # --- Relations ---
    messages = relationship("ChatMessage", back_populates="session", cascade="all, delete-orphan")
    tutor_decisions = relationship("TutorDecision", back_populates="session")
    
    # --- RELATION VERS INTERACTION LOG CORRIGÉE ET ACTIVÉE ---
    logs = relationship("InteractionLog", back_populates="session", cascade="all, delete-orphan")
    # ----------------------------------------------------

class ChatMessage(Base):
    __tablename__ = "chat_messages"

    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"), nullable=False)
    
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    sender = Column(String(50), nullable=False) # student, patient, tutor
    content = Column(Text, nullable=False)
    
    # Suppression des champs qui n'existent plus dans la migration la plus récente
    # intention_detectee = Column(String(100))
    # sentiment_analyse = Column(String(50))
    message_metadata = Column(JSON)

    session = relationship("SimulationSession", back_populates="messages")


# === CLASSE 'InteractionLog' AJOUTÉE ===
# Ce modèle manquait, ce qui causait l'ImportError.
class InteractionLog(Base):
    __tablename__ = "interaction_logs"

    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    action_category = Column(String(50))
    action_type = Column(String(100))
    action_content = Column(JSON)
    response_latency = Column(Integer)
    charge_cognitive_estimee = Column(Float)
    est_pertinent = Column(Boolean)

    session = relationship("SimulationSession", back_populates="logs")


# === CLASSE 'LearnerAffectiveState' AJOUTÉE ===
# Ce modèle était également importé dans __init__.py mais manquant dans ce fichier.
class LearnerAffectiveState(Base):
    __tablename__ = "learner_affective_states"

    id = Column(Integer, primary_key=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("simulation_sessions.id"))
    timestamp = Column(TIMESTAMP, server_default=text("now()"))
    stress_level = Column(Float)
    confidence_level = Column(Float)
    motivation_level = Column(Float)
    frustration_level = Column(Float)

    session = relationship("SimulationSession")

=== Fichier: ./models/prerequisite.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    ForeignKey,
    DECIMAL,
    text
)
from sqlalchemy.orm import relationship

from .base import Base


class Competence(Base):
    """
    Modèle SQLAlchemy pour les compétences cliniques (Knowledge Components).
    """
    __tablename__ = "competences_cliniques"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification ---
    code_competence = Column(String(50), unique=True, nullable=False, index=True, comment="Code unique (ex: 'ANAMNESE_DOULEUR')")
    nom = Column(String(255), nullable=False)
    categorie = Column(String(100), index=True, comment="Ex: Anamnese, Examen_physique, Raisonnement, Technique")
    
    # --- Pédagogie ---
    niveau_bloom = Column(Integer, comment="Niveau dans la taxonomie de Bloom (1-6)")
    description = Column(Text)
    objectifs_apprentissage = Column(JSON, comment="Liste détaillée des objectifs")
    criteres_maitrise = Column(JSON, comment="Critères pour valider la compétence")
    
    # --- Hiérarchie (Parent/Enfant) ---
    parent_competence_id = Column(Integer, ForeignKey("competences_cliniques.id"), nullable=True)
    ordre_apprentissage = Column(Integer, default=0)

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))

    # --- Relations ---
    children = relationship("Competence", 
                          back_populates="parent",
                          cascade="all, delete-orphan")
    
    parent = relationship("Competence", 
                        back_populates="children",
                        remote_side=[id])

    # Relation vers les prérequis
    prerequis = relationship(
        "Competence",
        secondary="prerequis_competences",
        primaryjoin="Competence.id==prerequis_competences.c.competence_id",
        secondaryjoin="Competence.id==prerequis_competences.c.prerequis_id",
        backref="est_prerequis_pour"
    )

    def __repr__(self) -> str:
        return f"<Competence(code='{self.code_competence}', nom='{self.nom}')>"


class PrerequisCompetence(Base):
    """
    Table d'association pour le graphe de prérequis entre compétences.
    Permet de dire : "Pour apprendre A, il faut d'abord maîtriser B".
    """
    __tablename__ = "prerequis_competences"

    id = Column(Integer, primary_key=True)
    
    # La compétence cible (Celle qu'on veut apprendre)
    competence_id = Column(Integer, ForeignKey("competences_cliniques.id"), nullable=False)
    
    # La compétence prérequise (Celle qu'on doit déjà avoir)
    prerequis_id = Column(Integer, ForeignKey("competences_cliniques.id"), nullable=False)
    
    # --- Métadonnées de la relation ---
    type_relation = Column(String(50), default="STRICT", comment="STRICT, RECOMMANDE, SUPPORTIF")
    force_relation = Column(DECIMAL(3, 2), default=1.0, comment="Force du lien (0-1)")

    def __repr__(self) -> str:
        return f"<Prerequis(target={self.competence_id}, needed={self.prerequis_id})>"

=== Fichier: ./models/__init__.py ===

# ==============================================================================
# FICHIER D'INITIALISATION DU PACKAGE 'models'
# ------------------------------------------------------------------------------
# Ce fichier centralise l'importation de toutes les classes de modèles SQLAlchemy,
# les rendant facilement accessibles depuis le reste de l'application via
# l'import `from app import models`.
# ==============================================================================

# --- Modèle de Base ---
from .base import Base

# --- Modèles du Domaine Expert ---
from .symptom import Symptom
from .disease import Disease
from .medication import Medication
from .media import ImageMedicale
from .clinical_case import ClinicalCase
from .expert_strategy import ExpertStrategy
from .relations import PathologieSymptome, TraitementPathologie, TraitementSymptome
from .prerequisite import Competence, PrerequisCompetence
from .expert_user import ExpertUser

# --- Modèles de l'Apprenant ---
from .learner_models import (
    Learner,
    LearnerCompetencyMastery,
    LearnerCognitiveProfile,
    LearnerMisconception,
    LearnerGoal,
    LearnerPreference,
    LearnerAchievement,
    LearnerStrategy
)

# --- Modèles de Suivi (Tracking) ---
from .tracking_models import (
    SimulationSession,
    ChatMessage,
    # La ligne ci-dessous est la correction clé pour l'erreur actuelle
    InteractionLog,
    LearnerAffectiveState
)

# --- Modèles du Tuteur ---
from .tutor_models import (
    LearningPath,
    TutorDecision,
    TutorStrategiesHistory,
    TutorScaffoldingState,
    TutorSocraticState,
    TutorMotivationalState,
    TutorFeedbackLog
)

# ==============================================================================
# FIN DU FICHIER
# ==============================================================================

=== Fichier: ./models/expert_user.py ===

from sqlalchemy import Column, Integer, String, Text, Boolean, TIMESTAMP, text
from sqlalchemy.orm import relationship
from .base import Base

class ExpertUser(Base):
    __tablename__ = "experts"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    nom_complet = Column(String(255))
    specialite = Column(String(100))
    hopital_affiliation = Column(String(255))
    role = Column(String(50), default="validateur") # superadmin, validateur, contributeur
    
    last_login = Column(TIMESTAMP)
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))

    # Relation avec les cas cliniques validés
    cas_valides = relationship("ClinicalCase", back_populates="expert_validateur")

=== Fichier: ./models/expert_strategy.py ===

from sqlalchemy import (
    DECIMAL,
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    Boolean,
    Date,
    text
)
from sqlalchemy.orm import relationship

from .base import Base


class ExpertStrategy(Base):
    """
    Modèle SQLAlchemy pour la table des règles de production (stratégies expertes).
    
    Cette table stocke la logique IF-THEN du système expert.
    """
    __tablename__ = "regles_production"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification et Métadonnées ---
    code_regle = Column(String(50), unique=True, nullable=False, index=True)
    categorie = Column(String(100), index=True, comment="Ex: DIAGNOSTIC, THERAPEUTIQUE, PEDAGOGIQUE, ALERTE")
    priorite = Column(Integer, default=5, comment="Priorité d'exécution (1-10), 10 étant le plus prioritaire")
    
    # --- Structure de la Règle (IF-THEN) ---
    conditions = Column(JSON, nullable=False, comment="Partie 'IF' de la règle, structurée en JSON")
    # Exemple de 'conditions':
    # {
    #   "operator": "AND",
    #   "rules": [
    #     {"fact": "symptom", "value": "Fièvre", "operator": "present"},
    #     {"fact": "symptom", "value": "Toux", "operator": "present"},
    #     {"fact": "age", "value": 65, "operator": "greater_than"}
    #   ]
    # }

    actions = Column(JSON, nullable=False, comment="Partie 'THEN' de la règle, structurée en JSON")
    # Exemple d' 'actions':
    # [
    #   {"action": "add_hypothesis", "pathology": "Pneumonie", "confidence": 0.8},
    #   {"action": "recommend_exam", "exam": "Radio Thorax", "urgency": "high"}
    # ]

    # --- Documentation et Validation ---
    description_naturelle = Column(Text, comment="Description de la règle en langage naturel")
    justification_medicale = Column(Text, comment="Source ou justification clinique de la règle")
    expert_auteur = Column(String(255))
    date_validation = Column(Date)
    est_active = Column(Boolean, default=True, nullable=False)

    # --- Métriques ---
    nb_activations = Column(Integer, default=0)
    taux_succes = Column(DECIMAL(5, 4))

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    def __repr__(self) -> str:
        return f"<ExpertStrategy(id={self.id}, code='{self.code_regle}')>"

=== Fichier: ./models/media.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    Boolean,
    Date,
    ForeignKey,
    text
)
from sqlalchemy.orm import relationship
from pgvector.sqlalchemy import Vector

from .base import Base


class ImageMedicale(Base):
    """
    Modèle SQLAlchemy pour la table des images médicales.
    Catalogue toutes les images (radios, scanners, etc.) avec leurs métadonnées.
    """
    __tablename__ = "images_medicales"

    id = Column(Integer, primary_key=True, index=True)

    # --- Classification et Liaison ---
    type_examen = Column(String(100), nullable=False, index=True, comment="Ex: Radiographie, Échographie, Scanner")
    sous_type = Column(String(100), comment="Ex: Thorax, Abdomen, Crâne")
    pathologie_id = Column(Integer, ForeignKey("pathologies.id"), nullable=True, index=True)

    # --- Gestion du Fichier ---
    fichier_url = Column(String(500), nullable=False, comment="URL vers le fichier (S3, stockage local, etc.)")
    fichier_miniature_url = Column(String(500), comment="URL vers une version miniature de l'image")
    format_image = Column(String(20), comment="Ex: DICOM, PNG, JPEG")
    taille_ko = Column(Integer)
    resolution = Column(String(50))

    # --- Métadonnées Cliniques ---
    description = Column(Text, comment="Description générale de l'image ou du cas")
    signes_radiologiques = Column(JSON, comment="Signes spécifiques visibles (ex: opacité, épanchement)")
    annotations = Column(JSON, comment="Coordonnées et descriptions de zones d'intérêt")
    interpretation_experte = Column(Text, comment="Compte-rendu d'un radiologue expert")
    diagnostic_differentiel = Column(JSON, comment="Autres diagnostics possibles basés sur l'image")

    # --- Métadonnées Pédagogiques ---
    niveau_difficulte = Column(Integer, comment="Difficulté d'interprétation de l'image (1-5)")
    qualite_image = Column(Integer, comment="Qualité technique de l'image (1-5)")

    # --- Intelligence Artificielle ---
    embedding_vision = Column(Vector(384), nullable=True, comment="Vecteur d'embedding pour la recherche par similarité visuelle")

    # --- Validation et Horodatage ---
    valide_expert = Column(Boolean, default=False)
    expert_validateur = Column(String(255))
    date_validation = Column(Date)
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))

    # --- Relations ---
    # Permet d'accéder à l'objet Pathologie depuis une ImageMedicale
    pathologie = relationship("Disease") # Nous n'avons pas besoin de back_populates ici pour l'instant

    def __repr__(self) -> str:
        return f"<ImageMedicale(id={self.id}, type='{self.type_examen}')>"


=== Fichier: ./models/knowledge_version.py ===



=== Fichier: ./models/disease.py ===

from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    JSON,
    TIMESTAMP,
    DECIMAL,
    text
)
from sqlalchemy.orm import relationship
from pgvector.sqlalchemy import Vector

from .base import Base


class Disease(Base):
    """
    Modèle SQLAlchemy pour la table des pathologies (maladies).

    Cette table contient toutes les informations détaillées sur chaque maladie
    connue par le système, y compris le contexte local, les caractéristiques
    cliniques et les vecteurs pour l'IA.
    """
    __tablename__ = "pathologies"

    id = Column(Integer, primary_key=True, index=True)

    # --- Identification et Classification ---
    code_icd10 = Column(String(20), unique=True, index=True, comment="Code international de la maladie (CIM-10)")
    nom_fr = Column(String(255), nullable=False, index=True)
    nom_en = Column(String(255))
    nom_local = Column(String(255), comment="Noms locaux ou courants au Cameroun")
    categorie = Column(String(100), index=True, comment="Ex: Infectieuse, Chronique, Parasitaire")

    # --- Données Cliniques et Épidémiologiques ---
    prevalence_cameroun = Column(DECIMAL(5, 2), comment="Prévalence en % dans le contexte camerounais")
    niveau_gravite = Column(Integer, comment="Échelle de 1 (bénin) à 5 (critique)")
    description = Column(Text)
    physiopathologie = Column(Text, comment="Mécanisme de la maladie")
    evolution_naturelle = Column(Text, comment="Comment la maladie évolue sans traitement")
    complications = Column(JSON, comment="Complications possibles")
    facteurs_risque = Column(JSON, comment="Facteurs de risque associés")
    prevention = Column(Text, comment="Mesures de prévention")

    # --- Intelligence Artificielle ---
    embedding_vector = Column(Vector(384), nullable=True, comment="Vecteur d'embedding pour la recherche sémantique")

    # --- Horodatage ---
    created_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"))
    updated_at = Column(TIMESTAMP, nullable=False, server_default=text("now()"), onupdate=text("now()"))

    # --- Relations ---
    # Nous préparons le terrain pour la future relation avec les symptômes.
    # Pour l'instant, elle reste en commentaire pour éviter les erreurs d'import circulaire.
    symptomes = relationship(
         "PathologieSymptome",
         back_populates="pathologie",
         cascade="all, delete-orphan"
    
     )
    
    traitements = relationship(
        "TraitementPathologie",
        back_populates="pathologie",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Disease(id={self.id}, nom_fr='{self.nom_fr}')>"

=== Fichier: ./models/diagnostic.py ===



=== Fichier: ./models/base.py ===

from sqlalchemy.orm import declarative_base

# Cette instance de 'declarative_base' est le catalogue central où SQLAlchemy
# enregistrera toutes les classes de modèles que nous définirons.
# C'est ce que Alembic utilisera pour comparer l'état de notre code
# avec l'état de la base de données.
Base = declarative_base()

=== Fichier: ./__init__.py ===



=== Fichier: ./services/fultang_integration/extractor.py ===



=== Fichier: ./services/fultang_integration/validator.py ===



=== Fichier: ./services/fultang_integration/__init__.py ===



=== Fichier: ./services/fultang_integration/anonymizer.py ===



=== Fichier: ./services/fultang_integration/case_generator.py ===



=== Fichier: ./services/simulation_service.py ===

import logging
from sqlalchemy.orm import Session
from uuid import UUID
from typing import Optional, List

from .. import models

logger = logging.getLogger(__name__)

def create_session(
    db: Session, 
    learner_id: int, 
    case_id: int, 
    session_type: str,
    formative_count: int = 0,
    formative_cases_pool: List[int] = None
) -> models.SimulationSession:
    """
    Crée un nouvel enregistrement de session de simulation dans la base de données.
    
    Args:
        db: La session de base de données.
        learner_id: L'ID de l'apprenant.
        case_id: L'ID du cas clinique sélectionné pour cette session.
        session_type: Le type de session ('test', 'formative', 'sommative').
        formative_count: Compteur de sessions formatives depuis la dernière évaluation.
        formative_cases_pool: Liste des IDs des cas formatifs pour l'évaluation sommative.
    
    Returns:
        L'objet SimulationSession qui vient d'être créé.
    """
    logger.info(f"[create_session] Création pour learner_id={learner_id}, case_id={case_id}")
    logger.info(f"  -> Type: {session_type}, Compteur formatif: {formative_count}")
    
    # Construction du contexte de session
    context = {
        "session_type": session_type,
        "formative_count_since_eval": formative_count,
        "dialogue": [],
        "formative_cases_pool": formative_cases_pool or []
    }
    
    logger.info(f"  -> Contexte de session: {context}")
    
    # Création de l'instance du modèle SQLAlchemy
    db_session = models.SimulationSession(
        learner_id=learner_id,
        cas_clinique_id=case_id,
        statut="in_progress",
        context_state=context
    )

    db.add(db_session)
    db.commit()
    db.refresh(db_session)

    logger.info(f"  -> ✅ Session créée avec succès. ID: {db_session.id}")
    return db_session


def get_session_by_id(db: Session, session_id: UUID) -> Optional[models.SimulationSession]:
    """
    Récupère une session de simulation par son ID.
    
    Args:
        db: La session de base de données.
        session_id: L'UUID de la session à récupérer.
    
    Returns:
        L'objet SimulationSession ou None si non trouvé.
    """
    return db.query(models.SimulationSession).filter(
        models.SimulationSession.id == session_id
    ).first()


def update_session_status(
    db: Session, 
    session_id: UUID, 
    new_status: str,
    score: float = None
) -> models.SimulationSession:
    """
    Met à jour le statut d'une session et optionnellement son score.
    
    Args:
        db: La session de base de données.
        session_id: L'UUID de la session à mettre à jour.
        new_status: Le nouveau statut ('in_progress', 'completed', 'abandoned').
        score: Le score final (optionnel).
    
    Returns:
        La session mise à jour.
    """
    session = get_session_by_id(db, session_id)
    if not session:
        raise ValueError(f"Session {session_id} introuvable.")
    
    session.statut = new_status
    if score is not None:
        session.score_final = score
    
    db.commit()
    db.refresh(session)
    
    logger.info(f"[update_session_status] Session {session_id} -> statut: {new_status}, score: {score}")
    return session

=== Fichier: ./services/ai_generation_service.py ===

import logging
import requests
import json
from typing import Dict, Any, List, Tuple
from sqlalchemy.orm import Session, joinedload

from .. import models, schemas
from ..config import settings

logger = logging.getLogger(__name__)

# Constantes pour l'API OpenRouter
OPENROUTER_API_URL = "https://openrouter.ai/api/v1/chat/completions"
# MISE A JOUR: Utilisation d'un modèle plus performant et toujours gratuit si disponible
MODEL_NAME = "mistralai/mistral-7b-instruct:free"

def _call_openrouter_api(prompt: str) -> Dict[str, Any]:
    """Fonction de base pour appeler l'API OpenRouter et parser la réponse JSON."""
    logger.info("Début de l'appel à l'API OpenRouter...")
    headers = {
        "Authorization": f"Bearer {settings.OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
    }
    data = {
        "model": MODEL_NAME,
        "messages": [{"role": "user", "content": prompt}],
        "response_format": {"type": "json_object"},
    }

    try:
        response = requests.post(OPENROUTER_API_URL, headers=headers, data=json.dumps(data), timeout=90)
        response.raise_for_status()
        response_json = response.json()
        content_str = response_json['choices'][0]['message']['content']
        logger.info("Réponse de l'IA reçue et parsée avec succès.")
        return json.loads(content_str)
    except requests.exceptions.RequestException as e:
        logger.error(f"Erreur lors de l'appel à l'API OpenRouter: {e}")
        # Retourner une structure d'erreur valide pour que le code appelant ne plante pas
        return {"error": "API call failed", "details": str(e), "score_diagnostic": 0, "score_therapeutique": 0, "score_demarche": 0, "feedback_global": "Erreur de connexion au service d'IA.", "recommendation_next_step": "Veuillez réessayer plus tard."}
    except (json.JSONDecodeError, KeyError, IndexError) as e:
        logger.error(f"Erreur lors du parsing de la réponse JSON de l'IA: {e}")
        return {"error": "Failed to parse AI response", "details": str(e), "score_diagnostic": 0, "score_therapeutique": 0, "score_demarche": 0, "feedback_global": "Erreur lors de l'interprétation de la réponse de l'IA.", "recommendation_next_step": "Veuillez réessayer plus tard."}

def generate_exam_result(case: models.ClinicalCase, session_history: List[str], exam_name: str) -> Dict[str, Any]:
    """Génère un résultat d'examen plausible en utilisant l'IA."""
    prompt = f"""
    ROLE: Tu es un simulateur de laboratoire médical ultra-réaliste.
    CONTEXTE: Un étudiant en médecine interagit avec un cas clinique simulé. La pathologie réelle du patient est "{case.pathologie_principale.nom_fr}". L'histoire de la maladie est: "{case.presentation_clinique.get('histoire_maladie', 'Non spécifiée')}".
    HISTORIQUE DES ACTIONS DE L'ÉTUDIANT: {json.dumps(session_history, indent=2)}
    TACHE: L'étudiant vient de demander l'examen suivant: "{exam_name}".
    INSTRUCTIONS:
    1. Génère un résultat réaliste pour cet examen.
    2. Le résultat doit être COHÉRENT avec la pathologie sous-jacente et l'historique.
    3. Ne révèle JAMAIS le diagnostic directement. Sois subtil. Si l'examen n'est pas pertinent, le résultat doit être normal.
    4. Réponds UNIQUEMENT avec un objet JSON. Ne fournis aucun texte avant ou après le JSON.
    5. Le JSON doit avoir deux clés: "rapport" (une chaîne décrivant les observations brutes) et "conclusion" (une chaîne avec l'interprétation médicale concise).
    EXEMPLE DE SORTIE: {{"rapport": "Créatinine: 150 µmol/L (Norme: 60-110). Urée: 10 mmol/L (Norme: 2.5-7.5).", "conclusion": "Insuffisance rénale modérée."}}
    """
    ai_response = _call_openrouter_api(prompt)
    return {"rapport": ai_response.get("rapport", "Erreur de génération du rapport."), "conclusion": ai_response.get("conclusion", "Aucune conclusion générée.")}

def generate_hint(case: models.ClinicalCase, session_history: List[str], hint_level: int) -> Tuple[str, str]:
    """Génère un indice contextuel en utilisant l'IA."""
    if hint_level == 0: hint_type_instruction = "une question socratique ouverte pour orienter sa réflexion initiale sur l'anamnèse."
    elif hint_level == 1: hint_type_instruction = "un rappel de cours ou de méthode clinique pertinent par rapport aux informations déjà collectées."
    elif hint_level == 2: hint_type_instruction = "un indice direct sur une action clé à entreprendre (examen physique ou paraclinique) qu'il n'a pas encore faite."
    else: hint_type_instruction = "un indice spécifique pointant vers un groupe de diagnostics possibles ou une anomalie clé à ne pas manquer."

    prompt = f"""
    ROLE: Tu es un tuteur médical pédagogue et bienveillant.
    CONTEXTE: Un étudiant gère un cas de "{case.pathologie_principale.nom_fr}".
    HISTORIQUE DES ACTIONS DE L'ÉTUDIANT: {json.dumps(session_history, indent=2)}
    TACHE: L'étudiant demande de l'aide. Il en est à sa {hint_level + 1}ème demande. Fournis {hint_type_instruction}
    INSTRUCTIONS:
    1. L'indice doit être court, utile et ne jamais donner la solution.
    2. Adapte l'indice à ce que l'étudiant a déjà fait ou n'a pas fait.
    3. Réponds UNIQUEMENT avec un objet JSON contenant les clés "hint_type" (choisis parmi: "question_socratique", "rappel_de_cours", "indice_direct", "indice_specifique") et "content".
    """
    ai_response = _call_openrouter_api(prompt)
    return ai_response.get("hint_type", "info"), ai_response.get("content", "Erreur lors de la génération de l'indice.")

def evaluate_final_submission(db: Session, case: models.ClinicalCase, submission: schemas.simulation.SubmissionRequest, session_history: list) -> Tuple[schemas.simulation.EvaluationResult, str, str]:
    """Évalue la soumission finale de l'apprenant en utilisant l'IA et retourne un objet Pydantic."""
    correct_pathology_name = case.pathologie_principale.nom_fr
    db_pathology_submitted = db.query(models.Disease).filter(models.Disease.id == submission.diagnosed_pathology_id).first()
    submitted_pathology_name = db_pathology_submitted.nom_fr if db_pathology_submitted else f"ID Inconnu ({submission.diagnosed_pathology_id})"
    
    correct_treatments_raw = db.query(models.TraitementPathologie).options(joinedload(models.TraitementPathologie.medicament)).filter(
        models.TraitementPathologie.pathologie_id == case.pathologie_principale_id
    ).all()
    correct_treatment_names = [t.medicament.nom_commercial or t.medicament.dci for t in correct_treatments_raw] if correct_treatments_raw else ["Aucun traitement spécifique défini"]

    submitted_meds_raw = db.query(models.Medication).filter(models.Medication.id.in_(submission.prescribed_medication_ids)).all()
    submitted_med_names = [m.nom_commercial or m.dci for m in submitted_meds_raw]

    ### MODIFICATION CLÉ : MISE À JOUR DU PROMPT POUR L'ÉCHELLE DE NOTATION /20 ###
    prompt = f"""
    ROLE: Tu es un professeur de médecine expert et juste, chargé d'évaluer la performance d'un étudiant sur une simulation de cas clinique.
    
    CONTEXTE DU CAS:
    - Diagnostic Correct: "{correct_pathology_name}"
    - Traitements Recommandés (liste informative): {json.dumps(correct_treatment_names)}
    
    SOUMISSION DE L'ÉTUDIANT:
    - Diagnostic Proposé: "{submitted_pathology_name}"
    - Traitements Prescrits: {json.dumps(submitted_med_names)}
    - Historique de sa démarche (actions effectuées): {json.dumps(session_history, indent=2)}

    TA MISSION:
    Évalue la performance et réponds UNIQUEMENT avec un objet JSON.
    Le JSON doit contenir EXACTEMENT les clés suivantes avec des notes flottantes:
    1. "score_diagnostic": note sur 10. (10 si exact, 5-7 si proche, 0 sinon).
    2. "score_therapeutique": note sur 5. (Évalue la pertinence du traitement prescrit PAR RAPPORT AU DIAGNOSTIC CORRECT).
    3. "score_demarche": note sur 5. (Évalue la logique et la pertinence des examens demandés. Une démarche logique peut avoir des points même si le diagnostic final est faux).
    4. "feedback_global": Un paragraphe concis de 3-4 phrases (point positif, axe d'amélioration, encouragement).
    5. "recommendation_next_step": Une phrase courte (choisis parmi: 'reprendre un cas de difficulté similaire', 'passer à un cas de difficulté supérieure', 'revoir les bases de cette catégorie').
    """
    
    ai_response = _call_openrouter_api(prompt)
    
    ### MODIFICATION CLÉ : LOGIQUE DE PARSING ROBUSTE ET CRÉATION DE L'OBJET PYDANTIC ###
    try:
        score_diag = float(ai_response.get("score_diagnostic", 0.0))
        score_ther = float(ai_response.get("score_therapeutique", 0.0))
        score_dem = float(ai_response.get("score_demarche", 0.0))
        
        # Calcul du score total sur 20
        score_total = round(score_diag + score_ther + score_dem, 2)
        
    except (ValueError, TypeError) as e:
        logger.error(f"Erreur de type dans les scores retournés par l'IA: {e}. Scores mis à 0.")
        score_diag, score_ther, score_dem, score_total = 0.0, 0.0, 0.0, 0.0

    # Création de l'objet Pydantic `EvaluationResult`
    eval_result = schemas.simulation.EvaluationResult(
        score_diagnostic=score_diag,
        score_therapeutique=score_ther,
        score_demarche=score_dem,
        score_total=score_total
    )
    
    feedback = ai_response.get("feedback_global", "Erreur lors de la génération du feedback.")
    recommendation = ai_response.get("recommendation_next_step", "Veuillez réessayer.")

    return eval_result, feedback, recommendation

=== Fichier: ./services/interaction_log_service.py ===

import logging
from sqlalchemy.orm import Session
from uuid import UUID
from .. import models, schemas

logger = logging.getLogger(__name__)

def create_interaction_log(db: Session, session_id: UUID, action_data: schemas.simulation.LearnerActionRequest) -> models.InteractionLog:
    session = db.query(models.SimulationSession).filter(models.SimulationSession.id == session_id).first()
    if not session:
        logger.error(f"[create_interaction_log] Tentative de log pour une session inexistante: {session_id}")
        raise ValueError(f"Session {session_id} non trouvée.")

    db_log = models.InteractionLog(
        session_id=session_id,
        action_category="EXAMINATION",
        action_type=action_data.action_type,
        action_content={
            "name": action_data.action_name,
            "justification": action_data.justification or None # Correction pour accepter None
        }
    )

    db.add(db_log)
    db.commit()
    db.refresh(db_log)
    return db_log

=== Fichier: ./services/__init__.py ===



=== Fichier: ./services/learning_path_service.py ===



=== Fichier: ./services/tutor_service.py ===

import logging
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import desc
from typing import List, Tuple, Dict, Any, Optional
from uuid import UUID
from datetime import datetime
import random

from .. import models, schemas
from . import simulation_service, disease_service, interaction_log_service, ai_generation_service

logger = logging.getLogger(__name__)

def _get_learner_history(db: Session, learner_id: int, category: str) -> List[models.SimulationSession]:
    """Récupère l'historique de l'apprenant pour une catégorie donnée, du plus récent au plus ancien."""
    logger.info(f"[_get_learner_history] Recherche de l'historique pour learner_id={learner_id}, category='{category}'")
    history = db.query(models.SimulationSession).join(
        models.ClinicalCase, models.SimulationSession.cas_clinique_id == models.ClinicalCase.id
    ).join(
        models.Disease, models.ClinicalCase.pathologie_principale_id == models.Disease.id
    ).filter(
        models.SimulationSession.learner_id == learner_id,
        models.Disease.categorie == category
    ).order_by(desc(models.SimulationSession.start_time)).all()
    logger.info(f"  -> {len(history)} session(s) trouvée(s) au total.")
    return history

def _select_case_for_activity(db: Session, category: str, session_type: str, last_score: Optional[float], seen_case_ids: List[int], learner_id: int, last_difficulty: int, formative_cases_ids: List[int] = []) -> models.ClinicalCase:
    """Sélectionne un cas clinique en fonction de la logique pédagogique."""
    logger.info(f"[_select_case_for_activity] Début de la sélection. Type: '{session_type}', dernier score: {last_score}, dernière difficulté: {last_difficulty}")
    logger.info(f"  -> IDs des cas déjà vus à exclure: {seen_case_ids}")

    # --- Logique pour Session Sommative ---
    if session_type == "sommative":
        if not formative_cases_ids:
            logger.error("Tentative de session sommative sans cas formatifs préalables !")
            raise ValueError("Erreur logique: session sommative demandée sans cas formatifs.")
        case_to_evaluate_id = random.choice(formative_cases_ids)
        logger.info(f"  -> Mode SOMMATIF: Sélection aléatoire du cas #{case_to_evaluate_id} parmi les cas formatifs {formative_cases_ids}")
        next_case = db.query(models.ClinicalCase).filter(models.ClinicalCase.id == case_to_evaluate_id).first()
        if not next_case: raise ValueError(f"Cas {case_to_evaluate_id} pour l'évaluation sommative introuvable.")
        logger.info(f"    -> ✅ Cas sommatif trouvé: #{next_case.id} (Niveau {next_case.niveau_difficulte})")
        return next_case

    # --- Logique pour Sessions 'test' ou 'formative' ---
    query = db.query(models.ClinicalCase).join(
        models.Disease, models.ClinicalCase.pathologie_principale_id == models.Disease.id
    ).filter(
        models.Disease.categorie == category,
        models.ClinicalCase.id.notin_(seen_case_ids)
    )
    
    difficulty_target = last_difficulty
    if session_type == "test":
        logger.info("  -> Mode TEST: Vise une difficulté de départ autour de 10.")
        difficulty_target = 10
    elif session_type == "formative":
        if last_score is not None:
            if last_score >= 12: # Seuil de réussite sur 20
                difficulty_target = last_difficulty + 3
                logger.info(f"  -> Mode FORMATIF (SUCCÈS): Progression -> vise niveau ~{difficulty_target}.")
            else:
                difficulty_target = last_difficulty
                logger.info(f"  -> Mode FORMATIF (ÉCHEC): Stagnation -> vise niveau ~{difficulty_target}.")
    
    # Filtrer par difficulté cible
    query = query.filter(models.ClinicalCase.niveau_difficulte.between(difficulty_target - 2, difficulty_target + 2))

    next_case = query.order_by(models.ClinicalCase.niveau_difficulte.asc()).first()
    
    # --- Logique de Fallback si aucun cas n'est trouvé à la difficulté cible ---
    if not next_case:
        logger.warning("  -> Aucun cas trouvé avec les filtres stricts. Passage au mode Fallback.")
        fallback_query = db.query(models.ClinicalCase).join(models.Disease, models.ClinicalCase.pathologie_principale_id == models.Disease.id).filter(
            models.Disease.categorie == category, models.ClinicalCase.id.notin_(seen_case_ids)
        )
        all_available_cases = fallback_query.all()
        if not all_available_cases:
            logger.error(f"  -> FALLBACK ÉCHOUÉ: Plus aucun cas non vu dans la catégorie '{category}'.")
            raise ValueError(f"Plus aucun cas clinique non résolu disponible dans la catégorie '{category}'.")

        # Trouver le cas le plus proche de la difficulté cible
        next_case = min(all_available_cases, key=lambda x: abs(x.niveau_difficulte - difficulty_target))
        logger.info(f"    -> Fallback: Cas le plus proche du niveau {difficulty_target} trouvé: #{next_case.id} (Niveau {next_case.niveau_difficulte})")

    logger.info(f"    -> ✅ Cas final sélectionné: #{next_case.id} (Niveau {next_case.niveau_difficulte})")
    return next_case

def start_new_session(db: Session, learner_id: int, category: str) -> Tuple[models.SimulationSession, models.ClinicalCase, str]:
    logger.info(f"\n\n================ [START] start_new_session pour learner #{learner_id}, category '{category}' ================")
    
    history = _get_learner_history(db, learner_id, category)
    
    # --- 1. REPRISE DE SESSION NON TERMINÉE ---
    last_session = history[0] if history else None
    if last_session and last_session.statut == "in_progress":
        logger.info(f"  -> Reprise de la session 'in_progress' existante: {last_session.id}")
        db.refresh(last_session, ["cas_clinique"])
        if last_session.cas_clinique: db.refresh(last_session.cas_clinique, ["pathologie_principale"])
        return last_session, last_session.cas_clinique, last_session.context_state.get("session_type", "formative")

    # --- 2. DÉTERMINATION DU TYPE DE LA NOUVELLE SESSION ---
    completed_history = [s for s in history if s.statut == "completed"]
    seen_case_ids = {s.cas_clinique_id for s in history} # Utiliser un set pour performance
    
    session_type = "test"
    last_score = None
    last_difficulty = 10 # Difficulté de base
    formative_cases_ids = []

    if not completed_history:
        logger.info("  -> Logique: Aucun historique complété. Démarrage session 'test'.")
    else:
        # Trouver la dernière évaluation (sommative ou test initial)
        last_eval = next((s for s in completed_history if s.context_state.get("session_type") in ["sommative", "test"]), None)
        
        if not last_eval:
             logger.info("  -> Logique: Sessions complétées mais aucune évaluation. On continue en 'formative'.")
             session_type = "formative"
        else:
            logger.info(f"  -> Logique: Dernière évaluation trouvée: Session ID {last_eval.id}, Score: {last_eval.score_final}, Fin: {last_eval.end_time}")
            last_eval_case = db.query(models.ClinicalCase).filter_by(id=last_eval.cas_clinique_id).first()
            last_difficulty = last_eval_case.niveau_difficulte if last_eval_case else 10
            
            # Compter les sessions formatives complétées *après* cette dernière évaluation
            formative_since_last_eval = [s for s in completed_history if s.end_time and s.end_time > last_eval.end_time and s.context_state.get("session_type") == "formative"]
            logger.info(f"  -> Logique: {len(formative_since_last_eval)} session(s) formative(s) complétée(s) depuis.")

            if len(formative_since_last_eval) >= 3:
                logger.info("  -> Logique: Cycle de 3 formatives terminé. Passage en 'sommative'.")
                session_type = "sommative"
                formative_cases_ids = [s.cas_clinique_id for s in formative_since_last_eval[:3]]
            else:
                logger.info("  -> Logique: Cycle formatif en cours. Nouvelle session 'formative'.")
                session_type = "formative"
                last_score = last_eval.score_final # Le score de la dernière éval guide la difficulté de la formative
                
    # --- 3. SÉLECTION DU CAS CLINIQUE ---
    next_clinical_case = _select_case_for_activity(db, category, session_type, last_score, list(seen_case_ids), learner_id, last_difficulty, formative_cases_ids)
    
    # --- 4. CRÉATION DE LA NOUVELLE SESSION ---
    new_session = simulation_service.create_session(
        db=db, learner_id=learner_id, case_id=next_clinical_case.id, session_type=session_type
    )
    
    db.refresh(new_session, ["cas_clinique"])
    if new_session.cas_clinique: db.refresh(new_session.cas_clinique, ["pathologie_principale"])

    logger.info(f"================ [END] start_new_session, nouvelle session: {new_session.id} (type: {session_type}) ================\n")
    return new_session, new_session.cas_clinique, session_type

def process_learner_action(db: Session, session_id: UUID, action_data: schemas.simulation.LearnerActionRequest) -> Tuple[Dict[str, Any], str]:
    """Traite une action de l'apprenant et génère un résultat via l'IA."""
    interaction_log_service.create_interaction_log(db=db, session_id=session_id, action_data=action_data)
    session = db.query(models.SimulationSession).options(joinedload(models.SimulationSession.cas_clinique).joinedload(models.ClinicalCase.pathologie_principale)).filter(models.SimulationSession.id == session_id).first()
    if not session: raise ValueError(f"Session {session_id} non trouvée.")
    history_logs = db.query(models.InteractionLog).filter(models.InteractionLog.session_id == session_id).order_by(models.InteractionLog.timestamp.asc()).all()
    session_history = [f"Action: {l.action_content.get('name')}, Justification: {l.action_content.get('justification') or 'N/A'}" for l in history_logs]
    action_result = ai_generation_service.generate_exam_result(case=session.cas_clinique, session_history=session_history, exam_name=action_data.action_name)
    return action_result, None # Feedback immédiat non implémenté pour l'instant

def _get_or_create_scaffolding_state(db: Session, session_id: UUID) -> models.TutorScaffoldingState:
    state = db.query(models.TutorScaffoldingState).filter(models.TutorScaffoldingState.session_id == session_id).first()
    if not state:
        state = models.TutorScaffoldingState(session_id=session_id, current_level=0, indices_deja_donnes=[])
        db.add(state); db.commit(); db.refresh(state)
    return state

def provide_hint(db: Session, session_id: UUID) -> Tuple[str, str]:
    """Fournit un indice à l'apprenant en suivant une logique de scaffolding."""
    state = _get_or_create_scaffolding_state(db, session_id)
    session = db.query(models.SimulationSession).options(joinedload(models.SimulationSession.cas_clinique).joinedload(models.ClinicalCase.pathologie_principale)).filter(models.SimulationSession.id == session_id).first()
    if not session: raise ValueError(f"Session {session_id} non trouvée.")
    history_logs = db.query(models.InteractionLog).filter(models.InteractionLog.session_id == session_id).all()
    session_history = [f"Action: {l.action_content.get('name')}" for l in history_logs]
    hint_type, hint_content = ai_generation_service.generate_hint(case=session.cas_clinique, session_history=session_history, hint_level=state.current_level)
    decision = models.TutorDecision(session_id=session_id, strategy_used="Scaffolding", action_choisie="Fournir un Indice", intervention_content=hint_content, rationale={"reason": "Demande de l'apprenant", "level": state.current_level})
    db.add(decision)
    state.current_level += 1
    db.commit()
    return hint_type, hint_content

def evaluate_submission(db: Session, session_id: UUID, submission_data: schemas.simulation.SubmissionRequest) -> Tuple[schemas.simulation.EvaluationResult, str, str]:
    """Évalue la soumission finale de l'apprenant."""
    logger.info(f"[evaluate_submission] Début de l'évaluation pour la session {session_id}")
    session = db.query(models.SimulationSession).options(joinedload(models.SimulationSession.cas_clinique).joinedload(models.ClinicalCase.pathologie_principale)).filter(models.SimulationSession.id == session_id).first()
    if not session: raise ValueError(f"Session {session_id} non trouvée.")
    if session.statut == "completed": raise ValueError("Cette session a déjà été évaluée.")

    case = session.cas_clinique
    logs = db.query(models.InteractionLog).filter(models.InteractionLog.session_id == session_id).all()
    history_for_eval = [{"type": log.action_type, "name": log.action_content.get('name'), "justification": log.action_content.get('justification')} for log in logs]
    
    # --- CORRECTION DU BUG ET DE LA LOGIQUE DE NOTATION ---
    # 1. L'IA retourne un objet Pydantic, pas un dictionnaire.
    # 2. Le score total de l'IA est sur 20 (10+5+5).
    # 3. Nous devons enregistrer ce score sur 20 en BDD.
    
    eval_result_from_ai, feedback, recommendation = ai_generation_service.evaluate_final_submission(db=db, case=case, submission=submission_data, session_history=history_for_eval)
    
    # Accès direct aux attributs de l'objet Pydantic (Correction du bug .get())
    score_diag = eval_result_from_ai.score_diagnostic
    score_ther = eval_result_from_ai.score_therapeutique
    score_dem = eval_result_from_ai.score_demarche
    
    # Le score total est déjà sur 20, pas besoin de conversion.
    score_total_sur_20 = eval_result_from_ai.score_total

    logger.info(f"  -> Scores bruts de l'IA: Diag={score_diag}/10, Thera={score_ther}/5, Demarche={score_dem}/5. Total={score_total_sur_20}/20.")

    # Mettre à jour la session avec le statut et le score correct
    session.statut = "completed"
    session.score_final = score_total_sur_20  # On stocke le score sur 20
    session.end_time = datetime.now()
    
    db.commit()
    logger.info(f"  -> Session {session_id} marquée comme 'completed' avec un score final de {session.score_final}/20.")
    
    # Retourner l'objet d'évaluation final
    return eval_result_from_ai, feedback, recommendation

=== Fichier: ./services/medication_service.py ===

from sqlalchemy.orm import Session
from typing import List, Optional

from .. import models, schemas

def get_medication_by_id(db: Session, medication_id: int) -> Optional[models.Medication]:
    """
    Récupère un médicament par son ID.
    """
    return db.query(models.Medication).filter(models.Medication.id == medication_id).first()

def get_medication_by_dci(db: Session, dci: str) -> Optional[models.Medication]:
    """
    Récupère un médicament par son DCI (Dénomination Commune Internationale).
    """
    return db.query(models.Medication).filter(models.Medication.dci == dci).first()

def get_all_medications(db: Session, skip: int = 0, limit: int = 100) -> List[models.Medication]:
    """
    Récupère une liste de tous les médicaments avec pagination.
    """
    return db.query(models.Medication).offset(skip).limit(limit).all()

def create_medication(db: Session, medication: schemas.MedicationCreate) -> models.Medication:
    """
    Crée un nouveau médicament dans la base de données.
    """
    medication_data = medication.model_dump()
    db_medication = models.Medication(**medication_data)
    
    db.add(db_medication)
    db.commit()
    db.refresh(db_medication)
    
    return db_medication

def update_medication(db: Session, medication_id: int, medication_update: schemas.MedicationUpdate) -> Optional[models.Medication]:
    """
    Met à jour un médicament existant.
    """
    db_medication = get_medication_by_id(db, medication_id)
    if not db_medication:
        return None

    update_data = medication_update.model_dump(exclude_unset=True)
    
    for key, value in update_data.items():
        setattr(db_medication, key, value)
        
    db.commit()
    db.refresh(db_medication)
    
    return db_medication

def delete_medication(db: Session, medication_id: int) -> Optional[models.Medication]:
    """
    Supprime un médicament de la base de données.
    """
    db_medication = get_medication_by_id(db, medication_id)
    if not db_medication:
        return None

    db.delete(db_medication)
    db.commit()
    
    return db_medication




# Contenu à AJOUTER à la fin de app/services/medication_service.py

def get_diseases_treated_by_medication(db: Session, medication_id: int) -> List[models.TraitementPathologie]:
    """
    Récupère toutes les pathologies traitées par un médicament.
    """
    return db.query(models.TraitementPathologie).filter(models.TraitementPathologie.medicament_id == medication_id).all()


def get_symptoms_treated_by_medication(db: Session, medication_id: int) -> List[models.TraitementSymptome]:
    """
    Récupère tous les symptômes traités par un médicament.
    """
    return db.query(models.TraitementSymptome).filter(models.TraitementSymptome.medicament_id == medication_id).all()

=== Fichier: ./services/media_service.py ===

import os
from sqlalchemy.orm import Session
from typing import List, Optional
from fastapi import UploadFile
import cloudinary
import cloudinary.uploader

from .. import models, schemas
from ..config import settings

# --- CONFIGURATION CLOUDINARY ---
# Cette configuration est faite une seule fois au chargement du module.
# Elle utilise les variables chargées depuis votre fichier .env.
cloudinary.config(
    cloud_name = settings.CLOUDINARY_CLOUD_NAME,
    api_key = settings.CLOUDINARY_API_KEY,
    api_secret = settings.CLOUDINARY_API_SECRET,
    secure = True
)


async def save_upload_file_to_cloud(upload_file: UploadFile) -> str:
    """
    Fonction utilitaire pour uploader un fichier directement vers Cloudinary
    et retourner son URL sécurisée.
    """
    try:
        # Lire le contenu du fichier en mémoire
        content = await upload_file.read()
        
        # Envoyer le contenu à Cloudinary
        upload_result = cloudinary.uploader.upload(
            content,
            folder="sti_medical_expert/uploads"  # Dossier de destination sur Cloudinary
        )
        
        # Récupérer l'URL sécurisée (https://...)
        secure_url = upload_result.get("secure_url")
        if not secure_url:
            raise Exception("Échec de l'upload vers Cloudinary, URL non retournée.")
            
        return secure_url
    finally:
        # Toujours fermer le fichier après lecture
        await upload_file.close()


async def create_image_medicale(
    db: Session,
    file: UploadFile,
    type_examen: str,
    sous_type: Optional[str] = None,
    pathologie_id: Optional[int] = None,
    description: Optional[str] = None
) -> models.ImageMedicale:
    """
    Crée une nouvelle entrée pour une image médicale.
    1. Sauvegarde le fichier sur Cloudinary.
    2. Crée l'enregistrement correspondant en base de données avec l'URL cloud.
    """
    # 1. Sauvegarder le fichier physique sur le cloud
    cloud_url = await save_upload_file_to_cloud(file)

    # 2. Créer l'objet SQLAlchemy avec les métadonnées et l'URL cloud
    db_image = models.ImageMedicale(
        type_examen=type_examen,
        sous_type=sous_type,
        pathologie_id=pathologie_id,
        description=description,
        fichier_url=cloud_url, # <-- C'est maintenant l'URL Cloudinary !
        format_image=file.content_type.split('/')[-1] if file.content_type else None,
        taille_ko=file.size // 1024 if file.size else None,
    )
    
    db.add(db_image)
    db.commit()
    db.refresh(db_image)
    
    return db_image


def get_image_medicale_by_id(db: Session, image_id: int) -> Optional[models.ImageMedicale]:
    """
    Récupère une image médicale par son ID.
    """
    return db.query(models.ImageMedicale).filter(models.ImageMedicale.id == image_id).first()


def get_all_images_medicales(db: Session, skip: int = 0, limit: int = 100) -> List[models.ImageMedicale]:
    """
    Récupère une liste de toutes les images médicales avec pagination.
    """
    return db.query(models.ImageMedicale).offset(skip).limit(limit).all()


def update_image_medicale_metadata(
    db: Session,
    image_id: int,
    image_update: schemas.ImageMedicaleUpdate
) -> Optional[models.ImageMedicale]:
    """
    Met à jour les métadonnées d'une image médicale existante.
    """
    db_image = get_image_medicale_by_id(db, image_id)
    if not db_image:
        return None

    update_data = image_update.model_dump(exclude_unset=True)
    
    for key, value in update_data.items():
        setattr(db_image, key, value)
        
    db.commit()
    db.refresh(db_image)
    
    return db_image


def delete_image_medicale(db: Session, image_id: int) -> Optional[models.ImageMedicale]:
    """
    Supprime une image médicale.
    1. Supprime l'enregistrement de la base de données.
    2. (Optionnel) Supprime le fichier sur Cloudinary.
    """
    db_image = get_image_medicale_by_id(db, image_id)
    if not db_image:
        return None

    # Optionnel : Ajouter ici la logique pour supprimer l'image de Cloudinary
    # via cloudinary.uploader.destroy(...) si vous voulez un nettoyage complet.
    # Pour l'instant, nous nous contentons de supprimer la référence.

    db.delete(db_image)
    db.commit()
    
    return db_image

=== Fichier: ./services/symptom_service.py ===

from sqlalchemy.orm import Session
from typing import List, Optional

from .. import models, schemas
from ..utils.exceptions import NotFoundException # Nous créerons ce fichier plus tard


def get_symptom_by_id(db: Session, symptom_id: int) -> Optional[models.Symptom]:
    """
    Récupère un symptôme par son ID.
    """
    return db.query(models.Symptom).filter(models.Symptom.id == symptom_id).first()


def get_symptom_by_name(db: Session, name: str) -> Optional[models.Symptom]:
    """
    Récupère un symptôme par son nom.
    """
    return db.query(models.Symptom).filter(models.Symptom.nom == name).first()


def get_all_symptoms(db: Session, skip: int = 0, limit: int = 100) -> List[models.Symptom]:
    """
    Récupère une liste de tous les symptômes avec pagination.
    """
    return db.query(models.Symptom).offset(skip).limit(limit).all()


def create_symptom(db: Session, symptom: schemas.SymptomCreate) -> models.Symptom:
    """
    Crée un nouveau symptôme dans la base de données.
    
    Prend un schéma Pydantic 'SymptomCreate' en entrée, le convertit en
    modèle SQLAlchemy 'Symptom' et l'ajoute à la base de données.
    """
    # Convertit le schéma Pydantic en dictionnaire
    symptom_data = symptom.model_dump()
    
    # Crée une instance du modèle SQLAlchemy
    db_symptom = models.Symptom(**symptom_data)
    
    # Ajoute l'instance à la session de la base de données
    db.add(db_symptom)
    # Valide la transaction pour l'écrire en base
    db.commit()
    # Rafraîchit l'instance pour obtenir les valeurs générées par la BDD (comme l'ID)
    db.refresh(db_symptom)
    
    return db_symptom


def update_symptom(db: Session, symptom_id: int, symptom_update: schemas.SymptomUpdate) -> Optional[models.Symptom]:
    """
    Met à jour un symptôme existant.
    """
    db_symptom = get_symptom_by_id(db, symptom_id)
    if not db_symptom:
        # Plus tard, nous lèverons une exception personnalisée
        # raise NotFoundException(detail=f"Symptom with id {symptom_id} not found")
        return None

    # Convertit le schéma Pydantic en dictionnaire, en excluant les valeurs non définies
    update_data = symptom_update.model_dump(exclude_unset=True)
    
    for key, value in update_data.items():
        setattr(db_symptom, key, value)
        
    db.commit()
    db.refresh(db_symptom)
    
    return db_symptom


def delete_symptom(db: Session, symptom_id: int) -> Optional[models.Symptom]:
    """
    Supprime un symptôme de la base de données.
    """
    db_symptom = get_symptom_by_id(db, symptom_id)
    if not db_symptom:
        # raise NotFoundException(detail=f"Symptom with id {symptom_id} not found")
        return None

    db.delete(db_symptom)
    db.commit()
    
    return db_symptom

def get_diseases_for_symptom(db: Session, symptom_id: int) -> List[models.PathologieSymptome]:
    """
    Récupère toutes les pathologies associées à un symptôme (diagnostic différentiel).
    """
    return db.query(models.PathologieSymptome).filter(models.PathologieSymptome.symptome_id == symptom_id).all()





def add_treatment_to_symptom(db: Session, association_data: schemas.relations.TraitementSymptomeCreate) -> models.TraitementSymptome:
    """
    Associe un médicament à un symptôme en tant que traitement symptomatique.
    """
    db_symptom = get_symptom_by_id(db, symptom_id=association_data.symptome_id)
    from . import medication_service
    db_medication = medication_service.get_medication_by_id(db, medication_id=association_data.medicament_id)

    if not db_symptom or not db_medication:
        raise ValueError("Symptôme ou Médicament non trouvé.")

    association = models.TraitementSymptome(**association_data.model_dump())
    
    db.add(association)
    db.commit()
    db.refresh(association)
    
    return association


def get_treatments_for_symptom(db: Session, symptom_id: int) -> List[models.TraitementSymptome]:
    """
    Récupère tous les traitements associés à un symptôme.
    """
    return db.query(models.TraitementSymptome).filter(models.TraitementSymptome.symptome_id == symptom_id).all()

=== Fichier: ./services/clinical_case_service.py ===

from sqlalchemy.orm import Session
from typing import List, Optional

from .. import models, schemas

# Importer les autres services dont nous aurons besoin
from . import disease_service
from . import media_service


def get_case_by_id(db: Session, case_id: int) -> Optional[models.ClinicalCase]:
    """
    Récupère un cas clinique par son ID.
    """
    return db.query(models.ClinicalCase).filter(models.ClinicalCase.id == case_id).first()


def get_case_by_code(db: Session, code: str) -> Optional[models.ClinicalCase]:
    """
    Récupère un cas clinique par son code Fultang ou synthétique.
    """
    return db.query(models.ClinicalCase).filter(models.ClinicalCase.code_fultang == code).first()


def get_all_cases(db: Session, skip: int = 0, limit: int = 100) -> List[models.ClinicalCase]:
    """
    Récupère une liste de tous les cas cliniques avec pagination.
    """
    return db.query(models.ClinicalCase).offset(skip).limit(limit).all()


def create_case(db: Session, case: schemas.ClinicalCaseCreate) -> models.ClinicalCase:
    """
    Crée un nouveau cas clinique dans la base de données.
    """
    # Vérifier que la pathologie principale existe, si elle est fournie
    if case.pathologie_principale_id:
        db_disease = disease_service.get_disease_by_id(db, disease_id=case.pathologie_principale_id)
        if not db_disease:
            raise ValueError(f"La pathologie avec l'ID {case.pathologie_principale_id} n'existe pas.")

    # Vérifier que les images associées existent, si elles sont fournies
    if case.images_associees_ids:
        for img_id in case.images_associees_ids:
            db_image = media_service.get_image_medicale_by_id(db, image_id=img_id)
            if not db_image:
                raise ValueError(f"L'image avec l'ID {img_id} n'existe pas.")

    case_data = case.model_dump()
    db_case = models.ClinicalCase(**case_data)
    
    db.add(db_case)
    db.commit()
    db.refresh(db_case)
    
    return db_case


def update_case(db: Session, case_id: int, case_update: schemas.ClinicalCaseUpdate) -> Optional[models.ClinicalCase]:
    """
    Met à jour un cas clinique existant.
    """
    db_case = get_case_by_id(db, case_id)
    if not db_case:
        return None

    update_data = case_update.model_dump(exclude_unset=True)
    
    for key, value in update_data.items():
        setattr(db_case, key, value)
        
    db.commit()
    db.refresh(db_case)
    
    return db_case


def delete_case(db: Session, case_id: int) -> Optional[models.ClinicalCase]:
    """
    Supprime un cas clinique de la base de données.
    Note : Ne supprime pas les entités associées (maladies, images...).
    """
    db_case = get_case_by_id(db, case_id)
    if not db_case:
        return None

    db.delete(db_case)
    db.commit()
    
    return db_case

=== Fichier: ./services/expert_strategy_service.py ===

from sqlalchemy.orm import Session
from typing import List, Optional

from .. import models, schemas

def get_strategy_by_id(db: Session, strategy_id: int) -> Optional[models.ExpertStrategy]:
    """
    Récupère une règle par son ID.
    """
    return db.query(models.ExpertStrategy).filter(models.ExpertStrategy.id == strategy_id).first()

def get_strategy_by_code(db: Session, code: str) -> Optional[models.ExpertStrategy]:
    """
    Récupère une règle par son code unique.
    """
    return db.query(models.ExpertStrategy).filter(models.ExpertStrategy.code_regle == code).first()

def get_all_strategies(db: Session, skip: int = 0, limit: int = 100) -> List[models.ExpertStrategy]:
    """
    Récupère une liste de toutes les règles avec pagination.
    """
    return db.query(models.ExpertStrategy).offset(skip).limit(limit).all()

def get_active_strategies_by_category(db: Session, category: str) -> List[models.ExpertStrategy]:
    """
    Récupère toutes les règles actives pour une catégorie donnée, triées par priorité.
    Cette fonction sera très utile pour le moteur de raisonnement.
    """
    return db.query(models.ExpertStrategy).filter(
        models.ExpertStrategy.categorie == category,
        models.ExpertStrategy.est_active == True
    ).order_by(models.ExpertStrategy.priorite.desc()).all()


def create_strategy(db: Session, strategy: schemas.ExpertStrategyCreate) -> models.ExpertStrategy:
    """
    Crée une nouvelle règle dans la base de données.
    """
    strategy_data = strategy.model_dump()
    db_strategy = models.ExpertStrategy(**strategy_data)
    
    db.add(db_strategy)
    db.commit()
    db.refresh(db_strategy)
    
    return db_strategy

def update_strategy(db: Session, strategy_id: int, strategy_update: schemas.ExpertStrategyUpdate) -> Optional[models.ExpertStrategy]:
    """
    Met à jour une règle existante.
    """
    db_strategy = get_strategy_by_id(db, strategy_id)
    if not db_strategy:
        return None

    update_data = strategy_update.model_dump(exclude_unset=True)
    
    for key, value in update_data.items():
        setattr(db_strategy, key, value)
        
    db.commit()
    db.refresh(db_strategy)
    
    return db_strategy

def delete_strategy(db: Session, strategy_id: int) -> Optional[models.ExpertStrategy]:
    """
    Supprime une règle de la base de données.
    """
    db_strategy = get_strategy_by_id(db, strategy_id)
    if not db_strategy:
        return None

    db.delete(db_strategy)
    db.commit()
    
    return db_strategy

=== Fichier: ./services/embedding_service.py ===

from sentence_transformers import SentenceTransformer
import logging

# Configuration du logging
logger = logging.getLogger(__name__)

class EmbeddingService:
    """
    Service pour générer des embeddings (vecteurs) à partir de texte.
    Utilise le modèle 'all-MiniLM-L6-v2' qui est un excellent compromis
    rapidité/qualité pour l'anglais et le français technique.
    """
    
    _instance = None
    _model = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(EmbeddingService, cls).__new__(cls)
            logger.info("Initialisation du modèle d'embedding...")
            # Chargement du modèle. On essaie sans le préfixe 'sentence-transformers/'
            # Si cela échoue encore, nous essaierons une autre approche.
            try:
                cls._model = SentenceTransformer('all-MiniLM-L6-v2')
            except Exception as e:
                logger.error(f"Erreur chargement modèle 'all-MiniLM-L6-v2': {e}")
                # Tentative de repli explicite
                cls._model = SentenceTransformer('sentence-transformers/all-MiniLM-L6-v2')
            
            logger.info("Modèle d'embedding chargé avec succès.")
        return cls._instance

    def get_text_embedding(self, text: str) -> list:
        """
        Génère un vecteur d'embedding pour une chaîne de caractères donnée.
        
        :param text: Le texte à vectoriser.
        :return: Une liste de flottants (le vecteur).
        """
        if not text or not isinstance(text, str):
            return None
            
        try:
            # Le modèle retourne un numpy array, on le convertit en liste simple
            # pour qu'il soit compatible avec pgvector et JSON.
            embedding = self._model.encode(text)
            return embedding.tolist()
        except Exception as e:
            logger.error(f"Erreur lors de la vectorisation du texte : {e}")
            return None

# Instance globale prête à l'emploi
embedding_service = EmbeddingService()

=== Fichier: ./services/chat_service.py ===

from sqlalchemy.orm import Session
from typing import List, Optional
from uuid import UUID

from .. import models, schemas


def create_chat_message(db: Session, session_id: UUID, message: schemas.ChatMessageCreate) -> models.ChatMessage:
    """
    Crée un nouveau message de chat et l'associe à une session.
    
    :param db: Session de base de données.
    :param session_id: L'ID de la session de simulation à laquelle le message appartient.
    :param message: Le schéma Pydantic contenant les données du message.
    :return: L'objet ChatMessage créé.
    """
    # Vérifier que la session parente existe pour garantir l'intégrité
    session = db.query(models.SimulationSession).filter(models.SimulationSession.id == session_id).first()
    if not session:
        raise ValueError(f"La session avec l'ID {session_id} n'a pas été trouvée.")

    # Créer l'instance du modèle SQLAlchemy
    db_message = models.ChatMessage(
        **message.model_dump(),
        session_id=session_id
    )
    
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    
    return db_message


def get_messages_by_session(db: Session, session_id: UUID) -> List[models.ChatMessage]:
    """
    Récupère tous les messages d'une session de simulation, triés par ordre chronologique.
    
    :param db: Session de base de données.
    :param session_id: L'ID de la session à interroger.
    :return: Une liste d'objets ChatMessage.
    """
    return db.query(models.ChatMessage).filter(
        models.ChatMessage.session_id == session_id
    ).order_by(models.ChatMessage.timestamp.asc()).all()

=== Fichier: ./services/diagnostic_engine.py ===

from sqlalchemy.orm import Session
from typing import List, Dict, Any, Optional

from .. import models
from ..core import reasoning_engine
from . import expert_strategy_service

# Pour le typage, nous pouvons définir un schéma simple ici
from pydantic import BaseModel

class DiagnosticInput(BaseModel):
    """
    Schéma simple pour les données d'entrée du moteur de diagnostic.
    """
    symptoms: List[str]
    context: List[str] = []
    age: Optional[int] = None
    # ... d'autres faits pertinents pourraient être ajoutés ici


def run_diagnostic(db: Session, patient_facts: DiagnosticInput) -> List[Dict[str, Any]]:
    """
    Orchestre le processus de diagnostic.

    1. Récupère les règles de diagnostic actives depuis la base de données.
    2. Formate les faits du patient.
    3. Appelle le moteur de raisonnement.
    4. Retourne les actions/conclusions.
    """
    # 1. Récupérer les règles
    # On utilise la fonction 'intelligente' que nous avions créée dans le service des stratégies
    diagnostic_rules_db = expert_strategy_service.get_active_strategies_by_category(
        db, category="DIAGNOSTIC"
    )

    if not diagnostic_rules_db:
        return []

    # Convertir les objets SQLAlchemy en dictionnaires simples pour le moteur de logique pure
    rules_list = [
        {
            "code_regle": rule.code_regle,
            "conditions": rule.conditions,
            "actions": rule.actions,
        }
        for rule in diagnostic_rules_db
    ]

    # 2. Formater les faits (déjà au bon format grâce à Pydantic)
    facts_dict = patient_facts.model_dump()

    # 3. Appeler le moteur de raisonnement
    conclusions = reasoning_engine.forward_chaining_engine(
        rules=rules_list,
        facts=facts_dict
    )

    # 4. Retourner les conclusions
    return conclusions

=== Fichier: ./services/q_matrix_service.py ===



=== Fichier: ./services/disease_service.py ===

from sqlalchemy.orm import Session
from typing import List, Optional

from .. import models, schemas

def get_disease_by_id(db: Session, disease_id: int) -> Optional[models.Disease]:
    """
    Récupère une pathologie par son ID.
    """
    return db.query(models.Disease).filter(models.Disease.id == disease_id).first()

def get_disease_by_icd10(db: Session, icd10_code: str) -> Optional[models.Disease]:
    """
    Récupère une pathologie par son code CIM-10.
    """
    return db.query(models.Disease).filter(models.Disease.code_icd10 == icd10_code).first()

def get_all_diseases(db: Session, skip: int = 0, limit: int = 100) -> List[models.Disease]:
    """
    Récupère une liste de toutes les pathologies avec pagination.
    """
    return db.query(models.Disease).offset(skip).limit(limit).all()

def create_disease(db: Session, disease: schemas.DiseaseCreate) -> models.Disease:
    """
    Crée une nouvelle pathologie dans la base de données.
    """
    disease_data = disease.model_dump()
    db_disease = models.Disease(**disease_data)
    
    db.add(db_disease)
    db.commit()
    db.refresh(db_disease)
    
    return db_disease

def update_disease(db: Session, disease_id: int, disease_update: schemas.DiseaseUpdate) -> Optional[models.Disease]:
    """
    Met à jour une pathologie existante.
    """
    db_disease = get_disease_by_id(db, disease_id)
    if not db_disease:
        return None

    update_data = disease_update.model_dump(exclude_unset=True)
    
    for key, value in update_data.items():
        setattr(db_disease, key, value)
        
    db.commit()
    db.refresh(db_disease)
    
    return db_disease

def delete_disease(db: Session, disease_id: int) -> Optional[models.Disease]:
    """
    Supprime une pathologie de la base de données.
    """
    db_disease = get_disease_by_id(db, disease_id)
    if not db_disease:
        return None

    db.delete(db_disease)
    db.commit()
    
    return db_disease

def add_symptom_to_disease(db: Session, association_data: schemas.relations.PathologieSymptomeCreate) -> models.PathologieSymptome:
    """
    Associe un symptôme à une pathologie avec des attributs de relation.
    """
    # Vérifier que la pathologie et le symptôme existent
    db_disease = get_disease_by_id(db, disease_id=association_data.pathologie_id)
    # Nous aurons besoin d'importer le symptom_service pour cette vérification
    from . import symptom_service
    db_symptom = symptom_service.get_symptom_by_id(db, symptom_id=association_data.symptome_id)

    if not db_disease or not db_symptom:
        # Idéalement, lever une exception plus spécifique
        raise ValueError("Pathologie ou Symptôme non trouvé.")

    # Créer l'objet d'association
    association = models.PathologieSymptome(**association_data.model_dump())
    
    db.add(association)
    db.commit()
    db.refresh(association)
    
    return association


def get_symptoms_for_disease(db: Session, disease_id: int) -> List[models.PathologieSymptome]:
    """
    Récupère tous les symptômes associés à une pathologie, avec les détails de la relation.
    """
    return db.query(models.PathologieSymptome).filter(models.PathologieSymptome.pathologie_id == disease_id).all()


def add_treatment_to_disease(db: Session, association_data: schemas.relations.TraitementPathologieCreate) -> models.TraitementPathologie:
    """
    Associe un médicament à une pathologie en tant que traitement.
    """
    db_disease = get_disease_by_id(db, disease_id=association_data.pathologie_id)
    from . import medication_service
    db_medication = medication_service.get_medication_by_id(db, medication_id=association_data.medicament_id)

    if not db_disease or not db_medication:
        raise ValueError("Pathologie ou Médicament non trouvé.")

    association = models.TraitementPathologie(**association_data.model_dump())
    
    db.add(association)
    db.commit()
    db.refresh(association)
    
    return association


def get_treatments_for_disease(db: Session, disease_id: int) -> List[models.TraitementPathologie]:
    """
    Récupère tous les traitements associés à une pathologie.
    """
    return db.query(models.TraitementPathologie).filter(models.TraitementPathologie.pathologie_id == disease_id).all()

=== Fichier: ./dependencies.py ===

# app/dependencies.py
from .database import SessionLocal

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

=== Fichier: ./middleware/logging_middleware.py ===



=== Fichier: ./middleware/__init__.py ===



=== Fichier: ./middleware/error_handler.py ===



=== Fichier: ./middleware/cors_middleware.py ===



=== Fichier: ./config.py ===

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # ... (existant)
    DATABASE_URL: str
    
    # --- AJOUT ---
    CLOUDINARY_CLOUD_NAME: str
    CLOUDINARY_API_KEY: str
    CLOUDINARY_API_SECRET: str

    OPENROUTER_API_KEY: str
    # -------------

    class Config:
        env_file = ".env"
        extra = "ignore"

settings = Settings()

=== Fichier: ./utils/anonymization.py ===



=== Fichier: ./utils/__init__.py ===



=== Fichier: ./utils/formatters.py ===



=== Fichier: ./utils/crypto.py ===



=== Fichier: ./utils/validators.py ===



=== Fichier: ./utils/exceptions.py ===

# app/utils/exceptions.py

class NotFoundException(Exception):
    """
    Exception personnalisée à lever lorsque'une ressource n'est pas trouvée
    dans la base de données.
    """
    def __init__(self, detail: str):
        self.detail = detail

=== Fichier: ./utils/logging.py ===

import logging
import os
import sys

def setup_logging():
    """
    Configure le logging pour écrire dans un fichier et sur la console.
    """
    # Créer le dossier de logs s'il n'existe pas
    log_dir = "logs"
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    log_file = os.path.join(log_dir, "simulation.log")

    # Créer un logger
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

    # Empêcher les double logs si la fonction est appelée plusieurs fois
    if logger.hasHandlers():
        logger.handlers.clear()

    # Formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'
    )

    # Handler pour écrire dans le fichier
    file_handler = logging.FileHandler(log_file, encoding='utf-8')
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # Handler pour afficher aussi dans la console (utile pour Render)
    stream_handler = logging.StreamHandler(sys.stdout)
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)

    logging.info("=" * 50)
    logging.info("Logging configuré. Les logs seront écrits ici et dans le fichier.")
    logging.info("=" * 50)

